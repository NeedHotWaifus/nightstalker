#!/usr/bin/env python3
"""
Utility Functions for Malware Framework
Common utilities used across the framework
"""

import os
import sys
import platform
import subprocess
import shutil
import tempfile
import hashlib
import json
import time
import random
import string
from pathlib import Path
from typing import Dict, Any, List, Optional, Union, Tuple
import logging
import re
import socket
import urllib.parse
from urllib.parse import urlparse, urljoin
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

logger = logging.getLogger(__name__)

class SystemUtils:
    """System utility functions"""
    
    @staticmethod
    def get_os_info() -> Dict[str, str]:
        """Get operating system information"""
        return {
            'system': platform.system(),
            'release': platform.release(),
            'version': platform.version(),
            'machine': platform.machine(),
            'processor': platform.processor(),
            'python_version': platform.python_version()
        }
    
    @staticmethod
    def is_windows() -> bool:
        """Check if running on Windows"""
        return platform.system().lower() == 'windows'
    
    @staticmethod
    def is_linux() -> bool:
        """Check if running on Linux"""
        return platform.system().lower() == 'linux'
    
    @staticmethod
    def is_macos() -> bool:
        """Check if running on macOS"""
        return platform.system().lower() == 'darwin'
    
    @staticmethod
    def get_user_home() -> Path:
        """Get user home directory"""
        return Path.home()
    
    @staticmethod
    def get_temp_dir() -> Path:
        """Get temporary directory"""
        return Path(tempfile.gettempdir())
    
    @staticmethod
    def get_current_user() -> str:
        """Get current username"""
        return os.getenv('USER', os.getenv('USERNAME', 'unknown'))
    
    @staticmethod
    def get_hostname() -> str:
        """Get system hostname"""
        return socket.gethostname()
    
    @staticmethod
    def get_ip_address() -> str:
        """Get local IP address"""
        try:
            # Connect to a remote address to determine local IP
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                s.connect(("8.8.8.8", 80))
                return s.getsockname()[0]
        except:
            return "127.0.0.1"
    
    @staticmethod
    def get_system_info() -> Dict[str, Any]:
        """Get comprehensive system information"""
        try:
            import psutil
            
            return {
                'os': SystemUtils.get_os_info(),
                'cpu': {
                    'count': psutil.cpu_count(),
                    'percent': psutil.cpu_percent(interval=1),
                    'freq': psutil.cpu_freq()._asdict() if psutil.cpu_freq() else None
                },
                'memory': {
                    'total': psutil.virtual_memory().total,
                    'available': psutil.virtual_memory().available,
                    'percent': psutil.virtual_memory().percent
                },
                'disk': {
                    'total': psutil.disk_usage('/').total,
                    'free': psutil.disk_usage('/').free,
                    'percent': psutil.disk_usage('/').percent
                },
                'network': {
                    'hostname': SystemUtils.get_hostname(),
                    'ip': SystemUtils.get_ip_address()
                }
            }
        except Exception as e:
            logger.error(f"Failed to get system info: {e}")
            return {}

class NetworkUtils:
    """Network utility functions"""
    
    @staticmethod
    def is_port_open(host: str, port: int, timeout: float = 5.0) -> bool:
        """Check if port is open on host"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                result = s.connect_ex((host, port))
                return result == 0
        except:
            return False
    
    @staticmethod
    def scan_ports(host: str, ports: List[int], timeout: float = 5.0) -> Dict[int, bool]:
        """Scan multiple ports on host"""
        results = {}
        
        def check_port(port: int) -> Tuple[int, bool]:
            return port, NetworkUtils.is_port_open(host, port, timeout)
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            future_to_port = {executor.submit(check_port, port): port for port in ports}
            
            for future in as_completed(future_to_port):
                port, is_open = future.result()
                results[port] = is_open
        
        return results
    
    @staticmethod
    def get_common_ports() -> List[int]:
        """Get list of common ports to scan"""
        return [
            21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995,  # Common services
            135, 139, 445, 1433, 1521, 3306, 5432, 6379, 8080, 8443,  # Database and web
            22, 23, 25, 53, 80, 110, 143, 443, 993, 995,  # Mail and web
            21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995  # FTP, SSH, etc.
        ]
    
    @staticmethod
    def resolve_domain(domain: str) -> Optional[str]:
        """Resolve domain to IP address"""
        try:
            return socket.gethostbyname(domain)
        except socket.gaierror:
            return None
    
    @staticmethod
    def get_domain_info(domain: str) -> Dict[str, Any]:
        """Get domain information"""
        info = {
            'domain': domain,
            'ip': None,
            'hostname': None,
            'aliases': []
        }
        
        try:
            hostname, aliases, addresses = socket.gethostbyaddr(domain)
            info['hostname'] = hostname
            info['aliases'] = aliases
            info['ip'] = addresses[0] if addresses else None
        except socket.herror:
            pass
        
        # Try reverse lookup
        if not info['ip']:
            info['ip'] = NetworkUtils.resolve_domain(domain)
        
        return info
    
    @staticmethod
    def is_valid_url(url: str) -> bool:
        """Validate URL format"""
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    @staticmethod
    def normalize_url(url: str) -> str:
        """Normalize URL format"""
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
        
        return url.rstrip('/')
    
    @staticmethod
    def get_url_parts(url: str) -> Dict[str, str]:
        """Parse URL into components"""
        parsed = urlparse(url)
        return {
            'scheme': parsed.scheme,
            'netloc': parsed.netloc,
            'path': parsed.path,
            'params': parsed.params,
            'query': parsed.query,
            'fragment': parsed.fragment
        }
    
    @staticmethod
    def download_file(url: str, filepath: str, timeout: int = 30) -> bool:
        """Download file from URL"""
        try:
            response = requests.get(url, stream=True, timeout=timeout)
            response.raise_for_status()
            
            with open(filepath, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            logger.info(f"File downloaded: {url} -> {filepath}")
            return True
        
        except Exception as e:
            logger.error(f"File download failed: {e}")
            return False

class FileUtils:
    """File utility functions"""
    
    @staticmethod
    def ensure_dir(path: Union[str, Path]) -> Path:
        """Ensure directory exists, create if necessary"""
        path = Path(path)
        path.mkdir(parents=True, exist_ok=True)
        return path
    
    @staticmethod
    def safe_filename(filename: str) -> str:
        """Convert filename to safe filesystem name"""
        # Remove or replace unsafe characters
        unsafe_chars = '<>:"/\\|?*'
        for char in unsafe_chars:
            filename = filename.replace(char, '_')
        
        # Limit length
        if len(filename) > 255:
            name, ext = os.path.splitext(filename)
            filename = name[:255-len(ext)] + ext
        
        return filename
    
    @staticmethod
    def get_file_hash(filepath: Union[str, Path], algorithm: str = 'sha256') -> str:
        """Calculate file hash"""
        filepath = Path(filepath)
        
        if not filepath.exists():
            raise FileNotFoundError(f"File not found: {filepath}")
        
        hash_func = hashlib.new(algorithm)
        
        with open(filepath, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_func.update(chunk)
        
        return hash_func.hexdigest()
    
    @staticmethod
    def copy_file_safe(src: Union[str, Path], dst: Union[str, Path]) -> bool:
        """Safely copy file with error handling"""
        try:
            src = Path(src)
            dst = Path(dst)
            
            if not src.exists():
                logger.error(f"Source file not found: {src}")
                return False
            
            # Ensure destination directory exists
            dst.parent.mkdir(parents=True, exist_ok=True)
            
            shutil.copy2(src, dst)
            logger.info(f"File copied: {src} -> {dst}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to copy file {src} -> {dst}: {e}")
            return False
    
    @staticmethod
    def read_json(filepath: Union[str, Path]) -> Optional[Dict[str, Any]]:
        """Read JSON file with error handling"""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to read JSON file {filepath}: {e}")
            return None
    
    @staticmethod
    def write_json(data: Dict[str, Any], filepath: Union[str, Path], indent: int = 2) -> bool:
        """Write JSON file with error handling"""
        try:
            filepath = Path(filepath)
            filepath.parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=indent, ensure_ascii=False)
            
            logger.info(f"JSON file written: {filepath}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to write JSON file {filepath}: {e}")
            return False
    
    @staticmethod
    def cleanup_old_files(directory: Union[str, Path], days: int = 30) -> int:
        """Clean up files older than specified days"""
        directory = Path(directory)
        if not directory.exists():
            return 0
        
        cutoff_time = time.time() - (days * 24 * 60 * 60)
        removed_count = 0
        
        try:
            for file_path in directory.rglob('*'):
                if file_path.is_file() and file_path.stat().st_mtime < cutoff_time:
                    file_path.unlink()
                    removed_count += 1
                    logger.debug(f"Removed old file: {file_path}")
        except Exception as e:
            logger.error(f"Error during cleanup: {e}")
        
        logger.info(f"Cleanup completed: {removed_count} files removed")
        return removed_count

class SecurityUtils:
    """Security utility functions"""
    
    @staticmethod
    def sanitize_input(input_str: str) -> str:
        """Sanitize user input to prevent injection attacks"""
        if not input_str:
            return ""
        
        # Remove potentially dangerous characters
        dangerous_chars = [';', '|', '&', '`', '$', '(', ')', '{', '}', '[', ']', '<', '>']
        for char in dangerous_chars:
            input_str = input_str.replace(char, '')
        
        # Remove multiple spaces
        input_str = re.sub(r'\s+', ' ', input_str)
        
        return input_str.strip()
    
    @staticmethod
    def validate_ip_address(ip: str) -> bool:
        """Validate IP address format"""
        try:
            socket.inet_aton(ip)
            return True
        except socket.error:
            return False
    
    @staticmethod
    def validate_domain(domain: str) -> bool:
        """Validate domain name format"""
        pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
        return bool(re.match(pattern, domain))
    
    @staticmethod
    def generate_random_string(length: int = 16) -> str:
        """Generate random string"""
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    @staticmethod
    def generate_session_id() -> str:
        """Generate unique session ID"""
        timestamp = int(time.time())
        random_part = SecurityUtils.generate_random_string(8)
        return f"session_{timestamp}_{random_part}"
    
    @staticmethod
    def hash_password(password: str, salt: Optional[str] = None) -> Tuple[str, str]:
        """Hash password with salt"""
        if salt is None:
            salt = SecurityUtils.generate_random_string(16)
        
        # Use PBKDF2 for password hashing
        import hashlib
        import os
        
        key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)
        return key.hex(), salt
    
    @staticmethod
    def verify_password(password: str, hashed: str, salt: str) -> bool:
        """Verify password against hash"""
        try:
            computed_hash, _ = SecurityUtils.hash_password(password, salt)
            return computed_hash == hashed
        except:
            return False

class ProcessUtils:
    """Process utility functions"""
    
    @staticmethod
    def is_process_running(process_name: str) -> bool:
        """Check if process is running"""
        try:
            if SystemUtils.is_windows():
                result = subprocess.run(['tasklist', '/FI', f'IMAGENAME eq {process_name}'], 
                                      capture_output=True, text=True)
                return process_name.lower() in result.stdout.lower()
            else:
                result = subprocess.run(['pgrep', '-f', process_name], 
                                      capture_output=True, text=True)
                return result.returncode == 0
        except:
            return False
    
    @staticmethod
    def kill_process(process_name: str) -> bool:
        """Kill process by name"""
        try:
            if SystemUtils.is_windows():
                subprocess.run(['taskkill', '/F', '/IM', process_name], 
                             capture_output=True, check=True)
            else:
                subprocess.run(['pkill', '-f', process_name], 
                             capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    @staticmethod
    def get_process_info(process_name: str) -> List[Dict[str, Any]]:
        """Get information about running processes"""
        processes = []
        
        try:
            if SystemUtils.is_windows():
                result = subprocess.run(['tasklist', '/FI', f'IMAGENAME eq {process_name}', '/FO', 'CSV'], 
                                      capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                
                for line in lines:
                    if line.strip():
                        parts = line.strip('"').split('","')
                        if len(parts) >= 5:
                            processes.append({
                                'name': parts[0],
                                'pid': parts[1],
                                'session': parts[2],
                                'memory': parts[4]
                            })
            else:
                result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                
                for line in lines:
                    if process_name in line:
                        parts = line.split()
                        if len(parts) >= 11:
                            processes.append({
                                'user': parts[0],
                                'pid': parts[1],
                                'cpu': parts[2],
                                'memory': parts[3],
                                'vsz': parts[4],
                                'rss': parts[5],
                                'tty': parts[6],
                                'stat': parts[7],
                                'start': parts[8],
                                'time': parts[9],
                                'command': ' '.join(parts[10:])
                            })
        except Exception as e:
            logger.error(f"Failed to get process info: {e}")
        
        return processes

class TimeUtils:
    """Time utility functions"""
    
    @staticmethod
    def get_timestamp() -> str:
        """Get current timestamp string"""
        return time.strftime('%Y-%m-%d %H:%M:%S')
    
    @staticmethod
    def get_timestamp_filename() -> str:
        """Get timestamp string suitable for filenames"""
        return time.strftime('%Y%m%d_%H%M%S')
    
    @staticmethod
    def format_duration(seconds: float) -> str:
        """Format duration in human-readable format"""
        if seconds < 60:
            return f"{seconds:.1f}s"
        elif seconds < 3600:
            minutes = seconds / 60
            return f"{minutes:.1f}m"
        else:
            hours = seconds / 3600
            return f"{hours:.1f}h"
    
    @staticmethod
    def sleep_with_jitter(base_delay: float, jitter_factor: float = 0.1) -> None:
        """Sleep with random jitter to avoid detection"""
        jitter = random.uniform(-jitter_factor, jitter_factor)
        actual_delay = max(0, base_delay + jitter)
        time.sleep(actual_delay)

# Convenience functions
def get_os_info() -> Dict[str, str]:
    """Get operating system information"""
    return SystemUtils.get_os_info()

def is_port_open(host: str, port: int, timeout: float = 5.0) -> bool:
    """Check if port is open on host"""
    return NetworkUtils.is_port_open(host, port, timeout)

def sanitize_input(input_str: str) -> str:
    """Sanitize user input"""
    return SecurityUtils.sanitize_input(input_str)

def generate_random_string(length: int = 16) -> str:
    """Generate random string"""
    return SecurityUtils.generate_random_string(length)

def get_timestamp() -> str:
    """Get current timestamp"""
    return TimeUtils.get_timestamp() 