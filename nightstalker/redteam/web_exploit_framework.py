"""
NightStalker Web Exploitation Framework
Comprehensive modular framework for web penetration testing
Integrates with existing NightStalker web red teaming capabilities
"""

import os
import sys
import json
import time
import subprocess
import shutil
import platform
import requests
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union
import logging
import threading
from dataclasses import dataclass
from enum import Enum
import re
from nightstalker.utils.tool_manager import ToolManager

logger = logging.getLogger(__name__)

class ToolStatus(Enum):
    INSTALLED = "installed"
    MISSING = "missing"
    OUTDATED = "outdated"
    ERROR = "error"

@dataclass
class Tool:
    name: str
    command: str
    install_command: str
    check_command: str
    description: str
    category: str
    required: bool = True
    docker_image: Optional[str] = None
    git_repo: Optional[str] = None

class WebExploitFramework:
    def __init__(self, base_dir = None):
        base_dir_str = str(base_dir) if base_dir is not None else None
        self.base_dir = Path(base_dir_str) if base_dir_str is not None else Path.cwd() / "nightstalker_web"
        self.modules_dir = self.base_dir / "modules"
        self.loot_dir = self.base_dir / "loot"
        self.tools_dir = self.base_dir / "tools"
        self.config_file = self.base_dir / "config.json"
        self.log_file = self.base_dir / "framework.log"
        
        # Initialize directories
        self._init_directories()
        
        # Load configuration
        self.config = self._load_config()
        
        # Initialize tools
        self.tools = self._init_tools()
        
        # Current target
        self.current_target = None
        
        # Setup logging
        self._setup_logging()
    
    def _init_directories(self):
        """Initialize framework directories"""
        directories = [
            self.base_dir,
            self.modules_dir,
            self.loot_dir,
            self.tools_dir,
            self.modules_dir / "recon",
            self.modules_dir / "exploit", 
            self.modules_dir / "bruteforce",
            self.modules_dir / "post",
            self.modules_dir / "auxiliary"
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
    
    def _load_config(self) -> Dict[str, Any]:
        """Load framework configuration"""
        default_config = {
            "tools": {},
            "targets": {},
            "settings": {
                "auto_update": True,
                "docker_enabled": True,
                "proxy_enabled": False,
                "tunnel_enabled": False
            }
        }
        
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return json.load(f)
            except:
                return default_config
        else:
            return default_config
    
    def _save_config(self):
        """Save framework configuration"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def _setup_logging(self):
        """Setup framework logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.log_file),
                logging.StreamHandler()
            ]
        )
    
    def _init_tools(self) -> Dict[str, Tool]:
        """Initialize tool definitions"""
        return {
            # Network Tools
            "nc": Tool(
                name="netcat",
                command="nc",
                install_command="apt-get install netcat -y",
                check_command="which nc",
                description="Network utility for manual network interaction",
                category="network"
            ),
            
            # Exploitation Tools
            "msfconsole": Tool(
                name="Metasploit Framework",
                command="msfconsole",
                install_command="curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod +x msfinstall && ./msfinstall",
                check_command="which msfconsole",
                description="Advanced exploitation and post-exploitation framework",
                category="exploitation",
                git_repo="https://github.com/rapid7/metasploit-framework.git"
            ),
            
            # Web Testing Tools
            "sqlmap": Tool(
                name="SQLMap",
                command="sqlmap",
                install_command="pip3 install sqlmap",
                check_command="which sqlmap",
                description="Automated SQL injection and database takeover tool",
                category="web_testing",
                git_repo="https://github.com/sqlmapproject/sqlmap.git"
            ),
            
            "wpscan": Tool(
                name="WPScan",
                command="wpscan",
                install_command="gem install wpscan",
                check_command="which wpscan",
                description="WordPress security scanner",
                category="web_testing",
                git_repo="https://github.com/wpscanteam/wpscan.git"
            ),
            
            "nikto": Tool(
                name="Nikto",
                command="nikto",
                install_command="apt-get install nikto -y",
                check_command="which nikto",
                description="Web server scanner",
                category="web_testing"
            ),
            
            "dirsearch": Tool(
                name="Dirsearch",
                command="dirsearch",
                install_command="pip3 install dirsearch",
                check_command="which dirsearch",
                description="Web path scanner",
                category="web_testing",
                git_repo="https://github.com/maurosoria/dirsearch.git"
            ),
            
            "nuclei": Tool(
                name="Nuclei",
                command="nuclei",
                install_command="go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest",
                check_command="which nuclei",
                description="Fast vulnerability scanner",
                category="web_testing",
                git_repo="https://github.com/projectdiscovery/nuclei.git"
            ),
            
            "ffuf": Tool(
                name="Ffuf",
                command="ffuf",
                install_command="go install github.com/ffuf/ffuf@latest",
                check_command="which ffuf",
                description="Fast web fuzzer",
                category="web_testing",
                git_repo="https://github.com/ffuf/ffuf.git"
            ),
            
            "httpx": Tool(
                name="Httpx",
                command="httpx",
                install_command="go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest",
                check_command="which httpx",
                description="Fast and multi-purpose HTTP toolkit",
                category="web_testing",
                git_repo="https://github.com/projectdiscovery/httpx.git"
            ),
            
            # Bruteforce Tools
            "openbullet": Tool(
                name="OpenBullet 2",
                command="openbullet",
                install_command="docker pull openbullet/openbullet2",
                check_command="docker images | grep openbullet",
                description="Automated testing framework for web applications",
                category="bruteforce",
                docker_image="openbullet/openbullet2",
                git_repo="https://github.com/openbullet/OpenBullet2.git"
            ),
            
            # Proxy Tools
            "proxychains": Tool(
                name="Proxychains",
                command="proxychains",
                install_command="apt-get install proxychains -y",
                check_command="which proxychains",
                description="Proxy chain tool",
                category="proxy"
            ),
            
            # Tunnel Tools
            "ngrok": Tool(
                name="Ngrok",
                command="ngrok",
                install_command="curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null && echo 'deb https://ngrok-agent.s3.amazonaws.com buster main' | sudo tee /etc/apt/sources.list.d/ngrok.list && sudo apt update && sudo apt install ngrok",
                check_command="which ngrok",
                description="Secure tunnels to localhost",
                category="tunnel"
            ),
            
            # Additional Tools
            "burpsuite": Tool(
                name="Burp Suite Community",
                command="burpsuite",
                install_command="wget https://portswigger.net/burp/releases/download?product=community&version=2023.1.2&type=jar -O burpsuite.jar",
                check_command="ls burpsuite.jar",
                description="Web application security testing platform",
                category="web_testing",
                required=False
            ),
            # Recon Tools
            "sn1per": Tool(
                name="Sn1per",
                command=str(self.base_dir / "tools" / "sn1per" / "sn1per"),
                install_command=f"git clone https://github.com/1N3/Sn1per.git {self.base_dir}/tools/sn1per && cd {self.base_dir}/tools/sn1per && bash install.sh",
                check_command=f"ls {self.base_dir}/tools/sn1per/sn1per",
                description="Automated pentest framework for reconnaissance and scanning",
                category="recon",
                git_repo="https://github.com/1N3/Sn1per.git"
            )
        }
    
    def check_tool_status(self, tool_name: str) -> ToolStatus:
        """Check if a tool is installed and working (uses ToolManager)"""
        if tool_name not in self.tools:
            return ToolStatus.ERROR
        try:
            if ToolManager.is_tool_installed(tool_name):
                return ToolStatus.INSTALLED
            else:
                return ToolStatus.MISSING
        except Exception as e:
            logger.error(f"Error checking {tool_name}: {e}", exc_info=True)
            return ToolStatus.ERROR
    
    def install_tool(self, tool_name: str) -> bool:
        """Install a specific tool (uses ToolManager)"""
        if tool_name not in self.tools:
            logger.error(f"Tool {tool_name} not found")
            return False
        try:
            logger.info(f"Installing {tool_name}...")
            ToolManager.check_and_install_tools([tool_name], logger)
            status = self.check_tool_status(tool_name)
            if status == ToolStatus.INSTALLED:
                self.config["tools"][tool_name] = {
                    "installed": True,
                    "install_date": time.time()
                }
                self._save_config()
                return True
            else:
                logger.error(f"Failed to install {tool_name}")
                return False
        except Exception as e:
            logger.error(f"Error installing {tool_name}: {e}", exc_info=True)
            return False
    
    def install_all_tools(self) -> Dict[str, bool]:
        """Install all required tools"""
        results = {}
        
        for tool_name, tool in self.tools.items():
            if tool.required:
                status = self.check_tool_status(tool_name)
                if status == ToolStatus.MISSING:
                    results[tool_name] = self.install_tool(tool_name)
                else:
                    results[tool_name] = (status == ToolStatus.INSTALLED)
        
        return results
    
    def run_tool(self, tool_name: str, args: Optional[List[str]] = None, target: Optional[str] = None) -> Tuple[bool, str]:
        """Run a specific tool"""
        if tool_name not in self.tools:
            return False, f"Tool {tool_name} not found"
        
        tool = self.tools[tool_name]
        status = self.check_tool_status(tool_name)
        
        if status != ToolStatus.INSTALLED:
            return False, f"Tool {tool_name} is not installed (status: {status.value})"
        
        # Prepare command
        cmd = [tool.command]
        if args is not None:
            cmd.extend(args)
        
        # Create output directory for target
        if target is not None:
            target_dir = self.loot_dir / str(target) / tool_name
            target_dir.mkdir(parents=True, exist_ok=True)
            output_file = target_dir / f"{tool_name}_{int(time.time())}.txt"
        else:
            output_file = None
        
        try:
            logger.info(f"Running {tool.name} with args: {args}")
            
            # Run tool
            if output_file:
                with open(output_file, 'w') as f:
                    result = subprocess.run(
                        cmd,
                        stdout=f,
                        stderr=subprocess.PIPE,
                        text=True,
                        timeout=300  # 5 minute timeout
                    )
            else:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
            
            if result.returncode == 0:
                logger.info(f"Successfully ran {tool.name}")
                return True, f"Tool executed successfully. Output: {output_file if output_file else 'captured'}"
            else:
                error_msg = result.stderr if result.stderr else "Unknown error"
                logger.error(f"Tool {tool.name} failed: {error_msg}")
                return False, f"Tool execution failed: {error_msg}"
                
        except subprocess.TimeoutExpired:
            logger.error(f"Tool {tool.name} timed out")
            return False, "Tool execution timed out"
        except Exception as e:
            logger.error(f"Error running {tool_name}: {e}")
            return False, f"Error: {e}"
    
    def set_target(self, target: str):
        """Set current target for operations"""
        self.current_target = target
        
        # Sanitize target for directory name (Windows compatibility)
        sanitized_target = re.sub(r'[<>:"/\\|?*]', '_', target)
        sanitized_target = sanitized_target.replace('https://', '').replace('http://', '')
        sanitized_target = sanitized_target.replace('://', '_').replace('/', '_')
        
        target_dir = self.loot_dir / sanitized_target
        target_dir.mkdir(parents=True, exist_ok=True)
        
        # Create target-specific directories
        for subdir in ["recon", "exploit", "bruteforce", "post", "screenshots", "logs"]:
            (target_dir / subdir).mkdir(exist_ok=True)
        
        logger.info(f"Target set to: {target} (directory: {sanitized_target})")
    
    def run_reconnaissance(self, target: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
        """Run reconnaissance modules"""
        if modules is None:
            modules = ["nuclei", "nikto", "dirsearch", "httpx"]
        
        results = {}
        self.set_target(target)
        
        for module in modules:
            if module in self.tools:
                logger.info(f"Running reconnaissance with {module}")
                
                # Prepare module-specific arguments
                args = self._get_recon_args(module, target)
                
                success, output = self.run_tool(module, args, target)
                results[module] = {
                    "success": success,
                    "output": output
                }
        
        return results
    
    def _get_recon_args(self, tool: str, target: str) -> List[str]:
        """Get reconnaissance arguments for specific tools"""
        args_map = {
            "nuclei": ["-u", target, "-silent"],
            "nikto": ["-h", target],
            "dirsearch": ["-u", target, "-e", "php,html,js"],
            "httpx": ["-u", target, "-silent"],
            "wpscan": ["--url", target, "--enumerate", "p,t,u"],
            "sqlmap": ["-u", target, "--batch", "--random-agent"],
            "sn1per": [target, str(self.loot_dir)]
        }
        
        return args_map.get(tool, [target])
    
    def run_exploitation(self, target: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
        """Run exploitation modules"""
        if modules is None:
            modules = ["sqlmap", "msfconsole"]
        
        results = {}
        self.set_target(target)
        
        for module in modules:
            if module in self.tools:
                logger.info(f"Running exploitation with {module}")
                
                # Prepare module-specific arguments
                args = self._get_exploit_args(module, target)
                
                success, output = self.run_tool(module, args, target)
                results[module] = {
                    "success": success,
                    "output": output
                }
        
        return results
    
    def _get_exploit_args(self, tool: str, target: str) -> List[str]:
        """Get exploitation arguments for specific tools"""
        args_map = {
            "sqlmap": ["-u", target, "--batch", "--random-agent", "--level", "5"],
            "msfconsole": ["-q", "-r", f"use auxiliary/scanner/http/dir_scanner; set RHOSTS {target}; run"],
            "nuclei": ["-u", target, "-t", "cves/", "-silent"]
        }
        
        return args_map.get(tool, [target])
    
    def run_bruteforce(self, target: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
        """Run bruteforce modules"""
        if modules is None:
            modules = ["openbullet"]
        
        results = {}
        self.set_target(target)
        
        for module in modules:
            if module in self.tools:
                logger.info(f"Running bruteforce with {module}")
                
                # Prepare module-specific arguments
                args = self._get_bruteforce_args(module, target)
                
                success, output = self.run_tool(module, args, target)
                results[module] = {
                    "success": success,
                    "output": output
                }
        
        return results
    
    def _get_bruteforce_args(self, tool: str, target: str) -> List[str]:
        """Get bruteforce arguments for specific tools"""
        args_map = {
            "openbullet": ["--config", f"{self.tools_dir}/openbullet/config.json", "--target", target]
        }
        
        return args_map.get(tool, [target])
    
    def run_post_exploitation(self, target: str, modules: Optional[List[str]] = None) -> Dict[str, Any]:
        """Run post-exploitation modules"""
        if modules is None:
            modules = ["msfconsole"]
        
        results = {}
        self.set_target(target)
        
        for module in modules:
            if module in self.tools:
                logger.info(f"Running post-exploitation with {module}")
                
                # Prepare module-specific arguments
                args = self._get_post_exploit_args(module, target)
                
                success, output = self.run_tool(module, args, target)
                results[module] = {
                    "success": success,
                    "output": output
                }
        
        return results
    
    def _get_post_exploit_args(self, tool: str, target: str) -> List[str]:
        """Get post-exploitation arguments for specific tools"""
        args_map = {
            "msfconsole": ["-q", "-r", f"use post/multi/gather/hashdump; set SESSION 1; run"]
        }
        
        return args_map.get(tool, [target])
    
    def get_tool_status_report(self) -> Dict[str, Dict[str, Any]]:
        """Get comprehensive tool status report"""
        report = {}
        
        for tool_name, tool in self.tools.items():
            status = self.check_tool_status(tool_name)
            report[tool_name] = {
                "name": tool.name,
                "status": status.value,
                "category": tool.category,
                "required": tool.required,
                "description": tool.description,
                "command": tool.command
            }
        
        return report
    
    def create_wrapper_scripts(self):
        """Create wrapper scripts for easy tool access"""
        wrapper_dir = self.base_dir / "bin"
        wrapper_dir.mkdir(exist_ok=True)
        
        for tool_name, tool in self.tools.items():
            wrapper_path = wrapper_dir / tool_name
            
            if tool.docker_image:
                # Docker wrapper
                wrapper_content = f"""#!/bin/bash
docker run --rm -it {tool.docker_image} "$@"
"""
            else:
                # Standard wrapper
                wrapper_content = f"""#!/bin/bash
{tool.command} "$@"
"""
            
            with open(wrapper_path, 'w') as f:
                f.write(wrapper_content)
            
            # Make executable
            os.chmod(wrapper_path, 0o755)
        
        logger.info(f"Wrapper scripts created in {wrapper_dir}")
    
    def setup_proxy(self, proxy_type: str = "socks5", proxy_host: str = "127.0.0.1", proxy_port: str = "9050"):
        """Setup proxy configuration"""
        proxy_config = f"""
# Proxy configuration for NightStalker Web Exploitation Framework
{proxy_type} {proxy_host} {proxy_port}
"""
        
        proxy_file = self.base_dir / "proxychains.conf"
        with open(proxy_file, 'w') as f:
            f.write(proxy_config)
        
        self.config["settings"]["proxy_enabled"] = True
        self.config["settings"]["proxy_config"] = {
            "type": proxy_type,
            "host": proxy_host,
            "port": proxy_port
        }
        self._save_config()
        
        logger.info(f"Proxy configuration saved to {proxy_file}")
    
    def setup_tunnel(self, tunnel_type: str = "ngrok", port: int = 8080):
        """Setup tunnel configuration"""
        tunnel_config = {
            "type": tunnel_type,
            "port": port,
            "enabled": True
        }
        
        self.config["settings"]["tunnel_enabled"] = True
        self.config["settings"]["tunnel_config"] = tunnel_config
        self._save_config()
        
        logger.info(f"Tunnel configuration set up for {tunnel_type} on port {port}")
    
    def generate_report(self, target: str, output_file: Optional[str] = None) -> str:
        """Generate comprehensive report for target"""
        if output_file is None:
            # Sanitize target for filename
            sanitized_target = re.sub(r'[<>:"/\\|?*]', '_', target)
            sanitized_target = sanitized_target.replace('https://', '').replace('http://', '')
            sanitized_target = sanitized_target.replace('://', '_').replace('/', '_')
            output_file = str(self.loot_dir / sanitized_target / f"report_{int(time.time())}.html")
        
        # Collect all results
        sanitized_target = re.sub(r'[<>:"/\\|?*]', '_', target)
        sanitized_target = sanitized_target.replace('https://', '').replace('http://', '')
        sanitized_target = sanitized_target.replace('://', '_').replace('/', '_')
        target_dir = self.loot_dir / sanitized_target
        results = {
            "target": target,
            "timestamp": time.time(),
            "reconnaissance": {},
            "exploitation": {},
            "bruteforce": {},
            "post_exploitation": {}
        }
        
        # Read tool outputs
        for category in ["recon", "exploit", "bruteforce", "post"]:
            category_dir = target_dir / category
            if category_dir.exists():
                for tool_file in category_dir.glob("*.txt"):
                    tool_name = tool_file.stem.split("_")[0]
                    with open(tool_file, 'r') as f:
                        results[f"{category}_results"][tool_name] = f.read()
        
        # Generate HTML report
        html_report = self._generate_html_report(results)
        
        with open(output_file, 'w') as f:
            f.write(html_report)
        
        logger.info(f"Report generated: {output_file}")
        return output_file
    
    def _generate_html_report(self, results: Dict[str, Any]) -> str:
        """Generate HTML report from results"""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>NightStalker Web Exploitation Report - {results['target']}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }}
        .section {{ background: white; margin: 20px 0; padding: 20px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }}
        .tool-result {{ margin: 10px 0; padding: 10px; background: #f8f9fa; border-left: 4px solid #007bff; }}
        .success {{ border-left-color: #28a745; }}
        .error {{ border-left-color: #dc3545; }}
        pre {{ background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }}
        .timestamp {{ color: #6c757d; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>NightStalker Web Exploitation Framework</h1>
        <h2>Target: {results['target']}</h2>
        <p class="timestamp">Generated: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(results['timestamp']))}</p>
    </div>
    
    <div class="section">
        <h3>Executive Summary</h3>
        <p>Comprehensive web exploitation assessment completed using NightStalker framework.</p>
    </div>
    
    <div class="section">
        <h3>Reconnaissance Results</h3>
        {self._format_tool_results(results.get('reconnaissance_results', {}))}
    </div>
    
    <div class="section">
        <h3>Exploitation Results</h3>
        {self._format_tool_results(results.get('exploitation_results', {}))}
    </div>
    
    <div class="section">
        <h3>Bruteforce Results</h3>
        {self._format_tool_results(results.get('bruteforce_results', {}))}
    </div>
    
    <div class="section">
        <h3>Post-Exploitation Results</h3>
        {self._format_tool_results(results.get('post_exploitation_results', {}))}
    </div>
</body>
</html>
        """
        return html
    
    def _format_tool_results(self, results: Dict[str, str]) -> str:
        """Format tool results for HTML"""
        if not results:
            return "<p>No results available.</p>"
        
        html = ""
        for tool_name, output in results.items():
            html += f"""
            <div class="tool-result">
                <h4>{tool_name}</h4>
                <pre>{output[:1000]}{'...' if len(output) > 1000 else ''}</pre>
            </div>
            """
        return html

# Integration with existing NightStalker web red teaming
class NightStalkerWebExploitFramework(WebExploitFramework):
    """Enhanced Web Exploitation Framework integrated with NightStalker"""
    
    def __init__(self, base_dir = None):
        base_dir_str = str(base_dir) if base_dir is not None else None
        super().__init__(base_dir_str)
        self.nightstalker_webred = None
        self._init_nightstalker_integration()
    
    def _init_nightstalker_integration(self):
        """Initialize integration with NightStalker web red teaming"""
        try:
            from .webred import WebRedTeam
            self.nightstalker_webred = WebRedTeam()
            logger.info("NightStalker web red teaming integration initialized")
        except ImportError as e:
            logger.warning(f"NightStalker web red teaming not available: {e}")
    
    def run_comprehensive_assessment(self, target: str) -> Dict[str, Any]:
        """Run comprehensive assessment using both frameworks"""
        results = {
            "nightstalker_webred": {},
            "web_exploit_framework": {}
        }
        
        # Run NightStalker web red teaming
        if self.nightstalker_webred:
            logger.info("Running NightStalker web red teaming assessment...")
            try:
                nightstalker_results = self.nightstalker_webred.scan(target, ['recon', 'enum', 'vuln', 'tech'])
                results["nightstalker_webred"] = nightstalker_results
            except Exception as e:
                logger.error(f"NightStalker assessment failed: {e}")
                results["nightstalker_webred"] = {"error": str(e)}
        
        # Run Web Exploitation Framework
        logger.info("Running Web Exploitation Framework assessment...")
        try:
            # Reconnaissance
            recon_results = self.run_reconnaissance(target)
            results["web_exploit_framework"]["reconnaissance"] = recon_results
            
            # Exploitation
            exploit_results = self.run_exploitation(target)
            results["web_exploit_framework"]["exploitation"] = exploit_results
            
            # Bruteforce
            bruteforce_results = self.run_bruteforce(target)
            results["web_exploit_framework"]["bruteforce"] = bruteforce_results
            
            # Post-exploitation
            post_results = self.run_post_exploitation(target)
            results["web_exploit_framework"]["post_exploitation"] = post_results
            
        except Exception as e:
            logger.error(f"Web Exploitation Framework assessment failed: {e}")
            results["web_exploit_framework"] = {"error": str(e)}
        
        return results
    
    def generate_integrated_report(self, target: str, results: Dict[str, Any], output_file: Optional[str] = None) -> str:
        """Generate integrated report combining both frameworks"""
        if output_file is None:
            output_file = self.loot_dir / str(target) / f"integrated_report_{int(time.time())}.html"
        
        # Generate comprehensive HTML report
        html_report = self._generate_integrated_html_report(target, results)
        
        with open(str(output_file), 'w') as f:
            f.write(html_report)
        
        logger.info(f"Integrated report generated: {output_file}")
        return str(output_file)
    
    def _generate_integrated_html_report(self, target: str, results: Dict[str, Any]) -> str:
        """Generate integrated HTML report"""
        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>NightStalker Integrated Web Assessment Report - {target}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; text-align: center; }}
        .section {{ background: white; margin: 20px 0; padding: 25px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }}
        .framework-section {{ border-left: 5px solid #667eea; }}
        .nightstalker-section {{ border-left: 5px solid #764ba2; }}
        .tool-result {{ margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 5px; }}
        .success {{ border-left: 4px solid #28a745; }}
        .error {{ border-left: 4px solid #dc3545; }}
        .warning {{ border-left: 4px solid #ffc107; }}
        pre {{ background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 0.9em; }}
        .timestamp {{ color: #6c757d; font-size: 0.9em; }}
        .summary {{ background: #e3f2fd; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .metrics {{ display: flex; justify-content: space-around; margin: 20px 0; }}
        .metric {{ text-align: center; padding: 15px; background: #f8f9fa; border-radius: 5px; }}
        .metric-number {{ font-size: 2em; font-weight: bold; color: #667eea; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>üåô NightStalker Integrated Web Assessment</h1>
        <h2>Target: {target}</h2>
        <p class="timestamp">Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="section summary">
        <h3>üìä Executive Summary</h3>
        <p>Comprehensive web security assessment completed using NightStalker's integrated framework combining advanced reconnaissance, exploitation, and post-exploitation capabilities.</p>
        
        <div class="metrics">
            <div class="metric">
                <div class="metric-number">{len(results.get('nightstalker_webred', {}).get('findings', {}))}</div>
                <div>NightStalker Findings</div>
            </div>
            <div class="metric">
                <div class="metric-number">{len(results.get('web_exploit_framework', {}))}</div>
                <div>Framework Modules</div>
            </div>
            <div class="metric">
                <div class="metric-number">{len(self.tools)}</div>
                <div>Available Tools</div>
            </div>
        </div>
    </div>
    
    <div class="section framework-section">
        <h3>üîß Web Exploitation Framework Results</h3>
        {self._format_framework_results(results.get('web_exploit_framework', {}))}
    </div>
    
    <div class="section nightstalker-section">
        <h3>üåô NightStalker Web Red Teaming Results</h3>
        {self._format_nightstalker_results(results.get('nightstalker_webred', {}))}
    </div>
    
    <div class="section">
        <h3>üìã Recommendations</h3>
        <ul>
            <li>Review all identified vulnerabilities and prioritize based on severity</li>
            <li>Implement security patches and updates</li>
            <li>Conduct regular security assessments</li>
            <li>Implement proper logging and monitoring</li>
            <li>Consider implementing WAF and other security controls</li>
        </ul>
    </div>
</body>
</html>
        """
        return html
    
    def _format_framework_results(self, results: Dict[str, Any]) -> str:
        """Format framework results for HTML"""
        if not results or "error" in results:
            return f"<p class='error'>Framework assessment failed: {results.get('error', 'Unknown error')}</p>"
        
        html = ""
        for category, category_results in results.items():
            html += f"<h4>{category.title()}</h4>"
            if isinstance(category_results, dict):
                for tool, tool_result in category_results.items():
                    status_class = "success" if tool_result.get("success") else "error"
                    html += f"""
                    <div class="tool-result {status_class}">
                        <h5>{tool}</h5>
                        <p>Status: {'‚úÖ Success' if tool_result.get('success') else '‚ùå Failed'}</p>
                        <pre>{tool_result.get('output', 'No output')[:500]}{'...' if len(tool_result.get('output', '')) > 500 else ''}</pre>
                    </div>
                    """
            else:
                html += f"<p>{category_results}</p>"
        
        return html
    
    def _format_nightstalker_results(self, results: Dict[str, Any]) -> str:
        """Format NightStalker results for HTML"""
        if not results or "error" in results:
            return f"<p class='error'>NightStalker assessment failed: {results.get('error', 'Unknown error')}</p>"
        
        html = ""
        findings = results.get('findings', {})
        
        for category, finding in findings.items():
            html += f"<h4>{category.title()}</h4>"
            if isinstance(finding, dict):
                for key, value in finding.items():
                    html += f"""
                    <div class="tool-result">
                        <h5>{key}</h5>
                        <pre>{json.dumps(value, indent=2)[:500]}{'...' if len(json.dumps(value, indent=2)) > 500 else ''}</pre>
                    </div>
                    """
            else:
                html += f"<p>{finding}</p>"
        
        return html 