#!/usr/bin/env python3
"""
NightStalker Web Exploitation Framework Installer
Automated installer for web penetration testing tools and framework setup
"""

import os
import sys
import subprocess
import platform
import shutil
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import argparse

class WebExploitFrameworkInstaller:
    def __init__(self):
        self.system = platform.system().lower()
        self.distro = self._detect_distro()
        self.base_dir = Path.cwd() / "nightstalker_web"
        self.install_log = self.base_dir / "install.log"
        
        # Package managers
        self.package_managers = {
            "apt": "apt-get",
            "yum": "yum",
            "dnf": "dnf",
            "pacman": "pacman",
            "brew": "brew"
        }
        
        self.pkg_manager = self._detect_package_manager()
        
        # Installation status
        self.install_status = {
            "system_info": {},
            "tools_installed": [],
            "tools_failed": [],
            "dependencies_installed": [],
            "dependencies_failed": []
        }
    
    def _detect_distro(self) -> str:
        """Detect Linux distribution"""
        if self.system != "linux":
            return self.system
        
        try:
            with open("/etc/os-release", "r") as f:
                content = f.read().lower()
                if "kali" in content:
                    return "kali"
                elif "parrot" in content:
                    return "parrot"
                elif "ubuntu" in content or "debian" in content:
                    return "debian"
                elif "centos" in content or "rhel" in content:
                    return "rhel"
                elif "arch" in content:
                    return "arch"
                else:
                    return "unknown"
        except:
            return "unknown"
    
    def _detect_package_manager(self) -> str:
        """Detect available package manager"""
        for pkg_manager in ["apt", "yum", "dnf", "pacman", "brew"]:
            if shutil.which(pkg_manager):
                return pkg_manager
        return "apt"  # Default fallback
    
    def log(self, message: str, level: str = "INFO"):
        """Log installation messages"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"[{timestamp}] {level}: {message}"
        
        print(log_message)
        
        # Write to log file
        self.base_dir.mkdir(parents=True, exist_ok=True)
        with open(self.install_log, "a") as f:
            f.write(log_message + "\n")
    
    def run_command(self, command: str, capture_output: bool = True) -> Tuple[bool, str]:
        """Run system command"""
        try:
            self.log(f"Running: {command}")
            
            if capture_output:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                return result.returncode == 0, result.stdout + result.stderr
            else:
                result = subprocess.run(command, shell=True)
                return result.returncode == 0, ""
                
        except subprocess.TimeoutExpired:
            self.log(f"Command timed out: {command}", "ERROR")
            return False, "Command timed out"
        except Exception as e:
            self.log(f"Command failed: {command} - {e}", "ERROR")
            return False, str(e)
    
    def install_system_dependencies(self) -> bool:
        """Install system dependencies"""
        self.log("Installing system dependencies...")
        
        # Update package lists
        if self.pkg_manager in ["apt", "apt-get"]:
            success, output = self.run_command("sudo apt-get update")
            if not success:
                self.log("Failed to update package lists", "ERROR")
                return False
        
        # Install basic dependencies
        basic_deps = [
            "git", "curl", "wget", "python3", "python3-pip", "python3-venv",
            "build-essential", "libssl-dev", "libffi-dev", "python3-dev"
        ]
        
        if self.system == "darwin":  # macOS
            basic_deps = ["git", "curl", "wget", "python3"]
        
        for dep in basic_deps:
            if self.pkg_manager == "apt":
                success, output = self.run_command(f"sudo apt-get install -y {dep}")
            elif self.pkg_manager == "yum":
                success, output = self.run_command(f"sudo yum install -y {dep}")
            elif self.pkg_manager == "dnf":
                success, output = self.run_command(f"sudo dnf install -y {dep}")
            elif self.pkg_manager == "pacman":
                success, output = self.run_command(f"sudo pacman -S --noconfirm {dep}")
            elif self.pkg_manager == "brew":
                success, output = self.run_command(f"brew install {dep}")
            
            if success:
                self.install_status["dependencies_installed"].append(dep)
                self.log(f"Installed: {dep}")
            else:
                self.install_status["dependencies_failed"].append(dep)
                self.log(f"Failed to install: {dep}", "ERROR")
        
        return len(self.install_status["dependencies_failed"]) == 0
    
    def install_python_dependencies(self) -> bool:
        """Install Python dependencies"""
        self.log("Installing Python dependencies...")
        
        python_deps = [
            "requests", "beautifulsoup4", "lxml", "selenium", "paramiko",
            "cryptography", "pycryptodome", "colorama", "rich", "click"
        ]
        
        for dep in python_deps:
            success, output = self.run_command(f"pip3 install {dep}")
            if success:
                self.log(f"Installed Python package: {dep}")
            else:
                self.log(f"Failed to install Python package: {dep}", "ERROR")
        
        return True
    
    def install_go(self) -> bool:
        """Install Go programming language"""
        if shutil.which("go"):
            self.log("Go is already installed")
            return True
        
        self.log("Installing Go...")
        
        if self.system == "linux":
            # Download and install Go
            success, output = self.run_command(
                "wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz && "
                "sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz && "
                "echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc"
            )
        elif self.system == "darwin":
            success, output = self.run_command("brew install go")
        else:
            self.log("Go installation not supported on this system", "WARNING")
            return False
        
        if success:
            self.log("Go installed successfully")
            return True
        else:
            self.log("Failed to install Go", "ERROR")
            return False
    
    def install_docker(self) -> bool:
        """Install Docker"""
        if shutil.which("docker"):
            self.log("Docker is already installed")
            return True
        
        self.log("Installing Docker...")
        
        if self.system == "linux":
            # Install Docker using official script
            success, output = self.run_command(
                "curl -fsSL https://get.docker.com -o get-docker.sh && "
                "sudo sh get-docker.sh"
            )
        elif self.system == "darwin":
            success, output = self.run_command("brew install --cask docker")
        else:
            self.log("Docker installation not supported on this system", "WARNING")
            return False
        
        if success:
            self.log("Docker installed successfully")
            # Add user to docker group
            self.run_command("sudo usermod -aG docker $USER")
            return True
        else:
            self.log("Failed to install Docker", "ERROR")
            return False
    
    def install_ruby(self) -> bool:
        """Install Ruby and gems"""
        if shutil.which("ruby"):
            self.log("Ruby is already installed")
        else:
            self.log("Installing Ruby...")
            if self.system == "linux":
                success, output = self.run_command("sudo apt-get install -y ruby ruby-dev")
            elif self.system == "darwin":
                success, output = self.run_command("brew install ruby")
            
            if not success:
                self.log("Failed to install Ruby", "ERROR")
                return False
        
        # Install required gems
        gems = ["wpscan"]
        for gem in gems:
            success, output = self.run_command(f"gem install {gem}")
            if success:
                self.log(f"Installed Ruby gem: {gem}")
            else:
                self.log(f"Failed to install Ruby gem: {gem}", "ERROR")
        
        return True
    
    def install_metasploit(self) -> bool:
        """Install Metasploit Framework"""
        if shutil.which("msfconsole"):
            self.log("Metasploit Framework is already installed")
            return True
        
        self.log("Installing Metasploit Framework...")
        
        # Install using official installer
        success, output = self.run_command(
            "curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && "
            "chmod +x msfinstall && "
            "sudo ./msfinstall"
        )
        
        if success:
            self.log("Metasploit Framework installed successfully")
            self.install_status["tools_installed"].append("metasploit")
            return True
        else:
            self.log("Failed to install Metasploit Framework", "ERROR")
            self.install_status["tools_failed"].append("metasploit")
            return False
    
    def install_go_tools(self) -> bool:
        """Install Go-based tools"""
        go_tools = [
            ("nuclei", "github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest"),
            ("httpx", "github.com/projectdiscovery/httpx/cmd/httpx@latest"),
            ("ffuf", "github.com/ffuf/ffuf@latest"),
            ("subfinder", "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"),
            ("naabu", "github.com/projectdiscovery/naabu/v2/cmd/naabu@latest")
        ]
        
        for tool_name, tool_path in go_tools:
            if shutil.which(tool_name):
                self.log(f"{tool_name} is already installed")
                continue
            
            self.log(f"Installing {tool_name}...")
            success, output = self.run_command(f"go install -v {tool_path}")
            
            if success:
                self.log(f"{tool_name} installed successfully")
                self.install_status["tools_installed"].append(tool_name)
            else:
                self.log(f"Failed to install {tool_name}", "ERROR")
                self.install_status["tools_failed"].append(tool_name)
        
        return True
    
    def install_python_tools(self) -> bool:
        """Install Python-based tools"""
        python_tools = [
            ("sqlmap", "sqlmap"),
            ("dirsearch", "dirsearch"),
            ("theHarvester", "theHarvester")
        ]
        
        for tool_name, pip_package in python_tools:
            if shutil.which(tool_name):
                self.log(f"{tool_name} is already installed")
                continue
            
            self.log(f"Installing {tool_name}...")
            success, output = self.run_command(f"pip3 install {pip_package}")
            
            if success:
                self.log(f"{tool_name} installed successfully")
                self.install_status["tools_installed"].append(tool_name)
            else:
                self.log(f"Failed to install {tool_name}", "ERROR")
                self.install_status["tools_failed"].append(tool_name)
        
        return True
    
    def install_git_tools(self) -> bool:
        """Install tools from Git repositories"""
        git_tools = [
            ("OpenBullet2", "https://github.com/openbullet/OpenBullet2.git"),
            ("nuclei-templates", "https://github.com/projectdiscovery/nuclei-templates.git"),
            ("seclists", "https://github.com/danielmiessler/SecLists.git")
        ]
        
        tools_dir = self.base_dir / "tools"
        tools_dir.mkdir(parents=True, exist_ok=True)
        
        for tool_name, repo_url in git_tools:
            tool_dir = tools_dir / tool_name.lower()
            
            if tool_dir.exists():
                self.log(f"{tool_name} is already cloned")
                continue
            
            self.log(f"Cloning {tool_name}...")
            success, output = self.run_command(f"git clone {repo_url} {tool_dir}")
            
            if success:
                self.log(f"{tool_name} cloned successfully")
                self.install_status["tools_installed"].append(tool_name)
            else:
                self.log(f"Failed to clone {tool_name}", "ERROR")
                self.install_status["tools_failed"].append(tool_name)
        
        return True
    
    def setup_framework(self) -> bool:
        """Setup the web exploitation framework"""
        self.log("Setting up Web Exploitation Framework...")
        
        # Create framework structure
        framework_dir = self.base_dir / "framework"
        framework_dir.mkdir(parents=True, exist_ok=True)
        
        # Copy framework files
        framework_files = [
            "nightstalker/redteam/web_exploit_framework.py"
        ]
        
        for file_path in framework_files:
            if Path(file_path).exists():
                dest_path = framework_dir / Path(file_path).name
                shutil.copy2(file_path, dest_path)
                self.log(f"Copied {file_path} to framework")
        
        # Create wrapper scripts
        self._create_wrapper_scripts()
        
        # Create configuration
        self._create_config()
        
        # Create aliases
        self._create_aliases()
        
        return True
    
    def _create_wrapper_scripts(self):
        """Create wrapper scripts for tools"""
        bin_dir = self.base_dir / "bin"
        bin_dir.mkdir(exist_ok=True)
        
        wrapper_scripts = {
            "web-exploit": """#!/bin/bash
# NightStalker Web Exploitation Framework Wrapper
python3 -c "
from nightstalker.redteam.web_exploit_framework import NightStalkerWebExploitFramework
import sys

if __name__ == '__main__':
    framework = NightStalkerWebExploitFramework()
    if len(sys.argv) > 1:
        if sys.argv[1] == 'install':
            framework.install_all_tools()
        elif sys.argv[1] == 'scan':
            if len(sys.argv) > 2:
                framework.run_reconnaissance(sys.argv[2])
        elif sys.argv[1] == 'exploit':
            if len(sys.argv) > 2:
                framework.run_exploitation(sys.argv[2])
        else:
            print('Usage: web-exploit [install|scan|exploit] [target]')
    else:
        print('NightStalker Web Exploitation Framework')
        print('Usage: web-exploit [install|scan|exploit] [target]')
"
""",
            "nightstalker": """#!/bin/bash
# NightStalker CLI Wrapper
python3 -m nightstalker.cli "$@"
""",
            "setup-proxy": """#!/bin/bash
# Setup proxy configuration
python3 -c "
from nightstalker.redteam.web_exploit_framework import NightStalkerWebExploitFramework
framework = NightStalkerWebExploitFramework()
framework.setup_proxy('socks5', '127.0.0.1', '9050')
print('Proxy configuration set up successfully')
"
""",
            "setup-tunnel": """#!/bin/bash
# Setup tunnel configuration
python3 -c "
from nightstalker.redteam.web_exploit_framework import NightStalkerWebExploitFramework
framework = NightStalkerWebExploitFramework()
framework.setup_tunnel('ngrok', 8080)
print('Tunnel configuration set up successfully')
"
"""
        }
        
        for script_name, script_content in wrapper_scripts.items():
            script_path = bin_dir / script_name
            with open(script_path, 'w') as f:
                f.write(script_content)
            
            # Make executable
            os.chmod(script_path, 0o755)
            self.log(f"Created wrapper script: {script_name}")
    
    def _create_config(self):
        """Create framework configuration"""
        config = {
            "framework": {
                "version": "1.0.0",
                "base_dir": str(self.base_dir),
                "install_date": time.time()
            },
            "system": {
                "os": self.system,
                "distro": self.distro,
                "package_manager": self.pkg_manager
            },
            "tools": {
                "installed": self.install_status["tools_installed"],
                "failed": self.install_status["tools_failed"]
            },
            "settings": {
                "auto_update": True,
                "docker_enabled": True,
                "proxy_enabled": False,
                "tunnel_enabled": False
            }
        }
        
        config_file = self.base_dir / "config.json"
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        
        self.log("Framework configuration created")
    
    def _create_aliases(self):
        """Create shell aliases"""
        aliases = {
            "web-exploit": f"alias web-exploit='{self.base_dir}/bin/web-exploit'",
            "nightstalker": f"alias nightstalker='{self.base_dir}/bin/nightstalker'",
            "setup-proxy": f"alias setup-proxy='{self.base_dir}/bin/setup-proxy'",
            "setup-tunnel": f"alias setup-tunnel='{self.base_dir}/bin/setup-tunnel'"
        }
        
        # Detect shell
        shell = os.environ.get('SHELL', '/bin/bash')
        rc_file = Path.home() / f".{Path(shell).name}rc"
        
        if rc_file.exists():
            with open(rc_file, 'a') as f:
                f.write("\n# NightStalker Web Exploitation Framework Aliases\n")
                for alias_name, alias_cmd in aliases.items():
                    f.write(f"{alias_cmd}\n")
            
            self.log(f"Aliases added to {rc_file}")
        else:
            self.log("Could not find shell RC file for aliases", "WARNING")
    
    def run_full_installation(self) -> bool:
        """Run complete installation process"""
        self.log("Starting NightStalker Web Exploitation Framework installation...")
        self.log(f"System: {self.system} ({self.distro})")
        self.log(f"Package Manager: {self.pkg_manager}")
        
        # Record system info
        self.install_status["system_info"] = {
            "system": self.system,
            "distro": self.distro,
            "package_manager": self.pkg_manager,
            "python_version": sys.version,
            "install_date": time.time()
        }
        
        # Installation steps
        steps = [
            ("System Dependencies", self.install_system_dependencies),
            ("Python Dependencies", self.install_python_dependencies),
            ("Go Language", self.install_go),
            ("Docker", self.install_docker),
            ("Ruby and Gems", self.install_ruby),
            ("Metasploit Framework", self.install_metasploit),
            ("Go Tools", self.install_go_tools),
            ("Python Tools", self.install_python_tools),
            ("Git Tools", self.install_git_tools),
            ("Framework Setup", self.setup_framework)
        ]
        
        failed_steps = []
        
        for step_name, step_func in steps:
            self.log(f"\n{'='*50}")
            self.log(f"Step: {step_name}")
            self.log(f"{'='*50}")
            
            try:
                success = step_func()
                if not success:
                    failed_steps.append(step_name)
                    self.log(f"Step failed: {step_name}", "ERROR")
                else:
                    self.log(f"Step completed: {step_name}")
            except Exception as e:
                failed_steps.append(step_name)
                self.log(f"Step failed with exception: {step_name} - {e}", "ERROR")
        
        # Installation summary
        self.log(f"\n{'='*50}")
        self.log("INSTALLATION SUMMARY")
        self.log(f"{'='*50}")
        
        self.log(f"Tools installed: {len(self.install_status['tools_installed'])}")
        self.log(f"Tools failed: {len(self.install_status['tools_failed'])}")
        self.log(f"Dependencies installed: {len(self.install_status['dependencies_installed'])}")
        self.log(f"Dependencies failed: {len(self.install_status['dependencies_failed'])}")
        
        if failed_steps:
            self.log(f"Failed steps: {', '.join(failed_steps)}", "ERROR")
        else:
            self.log("All installation steps completed successfully!")
        
        # Save installation status
        status_file = self.base_dir / "install_status.json"
        with open(status_file, 'w') as f:
            json.dump(self.install_status, f, indent=2)
        
        self.log(f"Installation log: {self.install_log}")
        self.log(f"Installation status: {status_file}")
        
        return len(failed_steps) == 0
    
    def print_usage_instructions(self):
        """Print usage instructions after installation"""
        self.log("\n" + "="*60)
        self.log("NIGHTSTALKER WEB EXPLOITATION FRAMEWORK")
        self.log("="*60)
        
        self.log("\n📁 Framework Location:")
        self.log(f"   {self.base_dir}")
        
        self.log("\n🚀 Quick Start:")
        self.log("   1. Reload your shell: source ~/.bashrc")
        self.log("   2. Run framework: web-exploit")
        self.log("   3. Scan target: web-exploit scan https://target.com")
        self.log("   4. Run exploitation: web-exploit exploit https://target.com")
        
        self.log("\n🛠️  Available Commands:")
        self.log("   web-exploit          - Main framework interface")
        self.log("   nightstalker         - NightStalker CLI")
        self.log("   setup-proxy          - Setup proxy configuration")
        self.log("   setup-tunnel         - Setup tunnel configuration")
        
        self.log("\n📚 Documentation:")
        self.log("   - Framework Guide: WEB_RED_TEAMING_GUIDE.md")
        self.log("   - Installation Log: install.log")
        self.log("   - Configuration: config.json")
        
        self.log("\n⚠️  Important Notes:")
        self.log("   - Only use on authorized targets")
        self.log("   - Follow responsible disclosure practices")
        self.log("   - Keep tools updated regularly")
        
        self.log("\n🎯 Next Steps:")
        self.log("   1. Review installed tools and their status")
        self.log("   2. Configure proxy/tunnel if needed")
        self.log("   3. Test framework with authorized targets")
        self.log("   4. Customize configuration as needed")

def main():
    parser = argparse.ArgumentParser(description="NightStalker Web Exploitation Framework Installer")
    parser.add_argument("--skip-docker", action="store_true", help="Skip Docker installation")
    parser.add_argument("--skip-metasploit", action="store_true", help="Skip Metasploit installation")
    parser.add_argument("--install-only", nargs="+", help="Install only specific tools")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    
    args = parser.parse_args()
    
    # Setup logging
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    
    # Create installer
    installer = WebExploitFrameworkInstaller()
    
    # Run installation
    success = installer.run_full_installation()
    
    if success:
        installer.print_usage_instructions()
        print("\n✅ Installation completed successfully!")
        return 0
    else:
        print("\n❌ Installation completed with errors. Check the log for details.")
        return 1

if __name__ == "__main__":
    sys.exit(main()) 